<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/12/14/bao-gao-sou-ji/bao-gao-sou-ji/"/>
      <url>/2019/12/14/bao-gao-sou-ji/bao-gao-sou-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="来源知乎"><a href="#来源知乎" class="headerlink" title="来源知乎"></a>来源知乎</h4><p><a href="//www.zhihu.com/people/cao-ting-ting"><img src="https://pic2.zhimg.com/8d3488f89_xs.jpg" alt="曹婷婷"></a></p><p><a href="//www.zhihu.com/people/cao-ting-ting">曹婷婷</a></p><p>授之以渔和相关报告解读方法~（原创，转载请告知）</p><p>首先说下，找各行各业的行业报告的用途是什么？</p><p>如果是for公司的战略决策，或者产品方向，或者市场策略，或者产品设计，或者广告定价，或者投资，或者任何方向，不同的部分不同的人对行业报告的深浅度需求不一致。所以会需要不同层次的行业报告。</p><p>另外，行业报告良莠不齐，需要有一定的经验和对行业的理解来判断，而且不同行业报告的口径不一致，可能导致结论对接不上，所以在行业报告的选择和使用，解读和判断上也需要一定的经验和专业技能，否则引用臆断的行业报告结论来做出判断，危害巨大。</p><p>最后，行业报告的材料都是偏行业性质的，比较大范围和大规模，不一定适用本公司的具体情况。在获得大概的了解后，最好结合案头研究（行业报告），定性和定量的的研究来辅助定位问题和寻找解决方案。</p><p>好了，大概说下互联网行业报告大部分在哪里看，后续也会标注上大概如何解读和注意事项。<br>（需要了解哪个行业ctrl+f 查找本答案关键词即可找到对应链接）</p><p><strong>一，国内咨询机构网站数据报告列表</strong></p><ol><li><p><a href="https://link.zhihu.com/?target=http%3A//report.iresearch.cn/" target="_blank" rel="noopener">艾瑞研究-艾瑞网</a>（互联网行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//index.iresearch.com.cn/app" target="_blank" rel="noopener">艾瑞APP指数</a>-艾瑞网（移动App TOP 1000 月度活跃和日活跃）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//index.iresearch.com.cn/pc" target="_blank" rel="noopener">艾瑞PC指数</a>-艾瑞网（PC TOP 1000-月度活跃和日活跃）</p></li><li><a href="https://link.zhihu.com/?target=http%3A//www.199it.com/" target="_blank" rel="noopener">199IT互联网数据中心</a>-所有行业报告，内容繁多，支持搜索</li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.cnnic.net.cn/hlwfzyj/hlwxzbg/" target="_blank" rel="noopener">中国互联网络信息中心</a>-CNNIC数据可以当做互联网人口普查基础表来看  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.analysys.cn/article%23analysis" target="_blank" rel="noopener">数据新知 - 易观</a>（易观智库）-仅参考  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.umeng.com/reports.html%3Fspm%3D0.0.0.0.eIY17Q%26from%3Dhp" target="_blank" rel="noopener">【友盟+】数据报告</a>-（被阿里收购）仅参考  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.dcci.com.cn/report/index.html" target="_blank" rel="noopener">http://www.dcci.com.cn/report/index.html</a> （DCCI）-仅参考</p></li><li><a href="https://link.zhihu.com/?target=http%3A//cn.sino-mr.com/viewpoint" target="_blank" rel="noopener">北京赛诺市场研究有限责任公司</a>赛诺数据，智能机出货量的专业统计</li><li><p><a href="https://link.zhihu.com/?target=http%3A//mi.talkingdata.com/reports.html%3Fcategory%3Dall" target="_blank" rel="noopener">数据报告-移动观象台-TalkingData</a>（Talkingdata报告）-行业报告可看  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.iimedia.cn/%23shuju" target="_blank" rel="noopener">艾媒网-全球移动互联网行业数据发布平台/iiMedia Research出品</a>-行业报告可看</p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.dataeye.com/report" target="_blank" rel="noopener">DataEye大数据移动营销综合服务商-数据报告</a>-dataeye-偏手游方向  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//aso100.com/" target="_blank" rel="noopener">ASO100 - 专业App Store数据平台丨ASO优化专家平台丨iOS榜单排行榜查询工具</a></p></li><li><p>电影电视行业<a href="https://link.zhihu.com/?target=http%3A//www.entgroup.cn/report/f/" target="_blank" rel="noopener">免费报告列表页</a>-艺恩咨询（是个研究娱乐行业的公司，提供行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.dotour.cn/topics/data" target="_blank" rel="noopener">旅游数据报告-旅游圈</a>（旅游行业报告）</p></li><li><a href="https://link.zhihu.com/?target=https%3A//www.aldzs.com/bg" target="_blank" rel="noopener">小程序报告-阿拉丁统计</a></li><li>爱应用：<a href="https://link.zhihu.com/?target=https%3A//www.iai.cn/" target="_blank" rel="noopener">一个应用所有历史版本的产品分析截图记录</a>。</li><li><a href="https://link.zhihu.com/?target=https%3A//www.appannie.com/cn/" target="_blank" rel="noopener">Appannie</a>，看国外的人都下载什么应用</li><li><a href="https://link.zhihu.com/?target=https%3A//www.caasdata.com/index/report/index.html" target="_blank" rel="noopener">卡思数据-短视频网红分析数据分析</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.gjzq.com.cn/main/invest-advisory/index.html" target="_blank" rel="noopener">国金证券研究所</a>（国家宏观经济研究数据和报告）</li></ol><p>排名不分先后</p><p><strong>二，国家机构公开数据</strong></p><ol><li><a href="https://link.zhihu.com/?target=http%3A//www.catr.cn/kxyj/qwfb/qwsj/" target="_blank" rel="noopener">中国信通院-研究成果-权威发布-权威数据</a>国家智能机出货量的官方统计</li><li><a href="https://link.zhihu.com/?target=http%3A//www.camet.org.cn/index.php%3Fm%3Dcontent%26c%3Dindex%26a%3Dlists%26catid%3D18" target="_blank" rel="noopener">中国城市轨道交通协会</a>（有中国城市地铁线路的流量数据）</li></ol><p><strong>三，国内互联网公司数据报告网站列表</strong></p><ol><li><a href="https://link.zhihu.com/?target=http%3A//djt.qq.com/ppts/" target="_blank" rel="noopener">讲座PPT-腾讯大讲堂</a></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.tencent.com/zh-cn/investor.html" target="_blank" rel="noopener">Tencent 腾讯</a>-业绩报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//mta.qq.com/mta/operation/" target="_blank" rel="noopener">腾讯大数据</a>-腾讯云数据分析出来的行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//developer.baidu.com/report%3Ftype%3Dinvestigate" target="_blank" rel="noopener">百度开放服务平台</a>-百度云数据分析出来的行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//datamarket.baidu.com/app.html%23app/index" target="_blank" rel="noopener">百度数据研究中心 提供行业研究报告、行业分析报告</a>-百度数据中心报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.aliresearch.com/" target="_blank" rel="noopener">首页-阿里研究院</a>-阿里行业研究报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//tech.qq.com/biznext/list.html" target="_blank" rel="noopener">企鹅智酷_腾讯网</a>-腾讯出品行业报告</p></li><li><a href="https://link.zhihu.com/?target=https%3A//cdc.tencent.com/" target="_blank" rel="noopener">腾讯CDC</a> -腾讯交互设计报告</li><li><p><a href="https://link.zhihu.com/?target=http%3A//ued.baidu.com/case" target="_blank" rel="noopener">百度用户体验中心</a>-百度UED用户研究报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//gux.163.com/" target="_blank" rel="noopener">网易用户体验设计中心</a>-网易UED用户研究报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//c.youku.com/ykvr/index" target="_blank" rel="noopener">网络视频数据报告</a>-优酷指数行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.pptv.com/aboutus/download/" target="_blank" rel="noopener">PP指数_PPTV聚力</a>-PPTV指数行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//zt.360.cn/report/" target="_blank" rel="noopener">360研究报告_360安全中心</a>-360应用商店等产品出品报告</p></li></ol><p>排名不分先后</p><p><strong>四，国外咨询机构网站数据报告列表（国外咨询机构较多，数据详实，无论是海外出海产品，海外报告中多有亚洲和中国的重点研究，相关报告和趋势分析都可以选看）</strong></p><ol><li><p><a href="https://link.zhihu.com/?target=http%3A//www.flurry.com/" target="_blank" rel="noopener">Flurry</a>-国外app行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//cn.blog.appannie.com/" target="_blank" rel="noopener">App Annie Blog</a>-app指数报告  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.appannie.com/insights/" target="_blank" rel="noopener">https://www.appannie.com/insights/</a> (Appnnie的行业包括，包括app 分发行业的分发量和收入）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//intelligence.businessinsider.com/" target="_blank" rel="noopener">BI Intelligence</a>-business insider的报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.emarketer.com/Articles" target="_blank" rel="noopener">Today&#x27;s Articles on Digital Marketing and Media</a>-emarker的报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.newzoo.com/category/press-releases/" target="_blank" rel="noopener">http://www.newzoo.com/category/press-releases/</a>-newzoo侧重于手游行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.gartner.com/newsroom/archive/" target="_blank" rel="noopener">Gartner Press Release Archives</a>-gartner侧重于硬件的出货量，包括智能机和PC等  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.idc.com/search/geography/perform_.do%3Fpage%3D1%26hitsPerPage%3D25%26sortBy%3DRELEVANCY%26lang%3DEnglish%26srchIn%3DALLRESEARCH%26src%3D%26athrT%3D10%26geo%3D3_332%26cmpT%3D10%26pgT%3D10%26_xpn%3Dfalse" target="_blank" rel="noopener">IDC - Search Results</a>-IDC的硬件出货量全球报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.yozzo.com/news-and-information" target="_blank" rel="noopener">Yozzo Telecom News</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.jpmorgan.com/pages/jpmorgan" target="_blank" rel="noopener">J.P. Morgan Home</a>-摩根投行报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.tohmatsu.com/view/en_JP/jp" target="_blank" rel="noopener">德勤中国 | 审计, 企业管理咨询, 财务咨询, 风险管理, 税务服务及行业洞察</a></p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.comscore.com/" target="_blank" rel="noopener">Precisely Everywhere</a>-comscore的互联网行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.ericsson.com/" target="_blank" rel="noopener">Ericsson - A world of communication</a>（Global移动行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.gamesindustry.biz/" target="_blank" rel="noopener">GamesIndustry.biz</a>（Global游戏行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//adfonic.com/" target="_blank" rel="noopener">http://adfonic.com/</a>（Global广告行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.canalys.com/" target="_blank" rel="noopener">Canalys | Insight. Innovation. Impact.</a>（Global智能机报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.juniperresearch.com/" target="_blank" rel="noopener">Mobile, Online &amp; Digital Market Research, Data &amp; Consultancy</a>（通信无线报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.gfk.com/Pages/default.aspx" target="_blank" rel="noopener">Home | GfK Global</a>（终端比较专业的报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.kantarworldpanel.com/global" target="_blank" rel="noopener">Kantar Worldpanel</a>（主要统计Android和ios的市场份额）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.pwc.com/us/en/publications.html" target="_blank" rel="noopener">PwC publications</a>（皮尤的所有用户，市场研究报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.fiksu.com/" target="_blank" rel="noopener">Fiksu | Data-fueled mobile marketing</a>（统计app用户获取成本和应用商店下载频次的监测）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.weforum.org/reports" target="_blank" rel="noopener">https://www.weforum.org/reports</a>（世界经济论坛的报告，揭示国内外发展的大趋势）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//blog.jampp.com/insights/" target="_blank" rel="noopener">Insights - Jampp</a> （Jampp是国外的app 的粘性和转化漏洞的网站，在insights里还有行业的app的retention等benchmark的数据，有些类似flurry的行业数据）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.rolandberger.com.cn/publications/publications_in_Greater_China/industry_reports/index.html" target="_blank" rel="noopener">罗兰贝格行业评论</a> 战略和行业评论和报告  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.pwccn.com/home/chi/libraryindex_chi.html" target="_blank" rel="noopener">普华永道:</a> blog 各个行业的主要发现和行业报告  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.similarweb.com/" target="_blank" rel="noopener">Website Traffic &amp; Mobile App Analytics</a> （similar web 以色列的网站分析工具，可以分析任何网站，包括用户，来源，终端，分布等等，数据非常棒）</p></li><li><a href="https://link.zhihu.com/?target=http%3A//www.cadas.com.cn/" target="_blank" rel="noopener">CADAS</a>（全球航空公司研究报告）：非常支持和专业</li><li><a href="https://link.zhihu.com/?target=http%3A//www.draphant.com/report" target="_blank" rel="noopener">印度互联网年报 - 竺帆 | 助力中企扬帆天竺</a> （印度出海报告，非常详细）</li><li><a href="https://link.zhihu.com/?target=https%3A//www.gsma.com/r/mobileeconomy/" target="_blank" rel="noopener">GSMA：</a> 全球移动互联网经济分析报告，全部免费下载报告和数据，从2015年到现在</li></ol><p>排名不分先后</p><p><strong>五，各大公司不定期发布的报告，比如（细分方向的时候用）</strong></p><ol><li><a href="https://link.zhihu.com/?target=http%3A//www.askci.com/news/chanye/2016/01/20/101053mz1i.shtml" target="_blank" rel="noopener">高德地图：2015年度中国主要城市交通分析报告</a></li><li><a href="https://link.zhihu.com/?target=http%3A//tech.qq.com/a/20151216/047691.htm" target="_blank" rel="noopener">微信城市服务发布《2015微信政务民生白皮书》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//socialbeta.com/t/report-taobao-consumption-trends-data" target="_blank" rel="noopener">【报告】淘宝发布 2015 中国消费趋势数据，2015 年我们为什么买单？</a></li><li><p><a href="https://link.zhihu.com/?target=https%3A//blog.growingio.com/posts/hu-lian-wang-chuang-ye-gong-si-yong-hu-zeng-zhang-shi-zhan-mi-ji" target="_blank" rel="noopener">互联网增长的第一本数据分析手册</a>-Growing IO的公开手册  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//blog.talkingdata.net/%3Fp%3D221" target="_blank" rel="noopener">移动游戏运营数据分析指标白皮书（一）</a>-Talkingdata 运营指标分析白皮书  </p></li></ol><p>排名不分先后<br>（不局限于以上list）</p><p><strong>六，企业信息报告</strong></p><ol><li><p><a href="https://link.zhihu.com/?target=http%3A//www.chinaipo.com/listed/" target="_blank" rel="noopener">新三板在线 - 中国最大的新三板生态平台</a>（各行各业的新三板上市公司财务数据，高管数据等）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.qichacha.com/" target="_blank" rel="noopener">企查查|企业查询</a>（查询企业的产品，品牌和法人信息）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.tianyancha.com/" target="_blank" rel="noopener">企业注册信息查询</a>（天眼查，同企查查）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.sec.gov/" target="_blank" rel="noopener">SEC.gov | Home</a>（美国上市公司年度财务报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.cninfo.com.cn/new/index" target="_blank" rel="noopener">巨潮资讯网—</a>（中国上市公司季度年度财务报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//ir.baidu.com/phoenix.zhtml%3Fc%3D188488%26p%3Dirol-irhome" target="_blank" rel="noopener">Baidu | Investors</a>（各大上市公司季度财报，IR.XX公司.com，比如百度这个）</p></li><li><a href="https://link.zhihu.com/?target=https%3A//www.tianyancha.com/" target="_blank" rel="noopener">天眼查</a>（可以查到各个企业的详细信息，还可以查到员工个数）</li></ol><p>排名不分先后</p><p><strong>七，爬虫网站或者App的数据</strong></p><p>最近研究发现，还有一个好的行业信息获取来源，就是通过站内或者App内的爬虫抓取，这个渠道获取的数据，通常可以帮助你了解行业和竞品的站内使用情况，用户喜欢的内容，用户的分布，用户的行为和喜好等等。</p><p>1，通常的搜索方式 是：你要了解的网站/App+爬虫，在搜索平台比如百度搜索</p><p>2，这里举例一些程序员垂直的网站，</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//www.csdn.net/" target="_blank" rel="noopener">CSDN网站</a>：在这个网站内搜索：网站/app +爬虫 这个关键词，在站内搜索</li><li><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/" target="_blank" rel="noopener">简书 - 创作你的创作</a>：在这个网站内搜索：网站/app +爬虫 这个关键词，在站内搜索，</li><li><a href="https://link.zhihu.com/?target=http%3A//jiasule.v2ex.com/" target="_blank" rel="noopener">V2EX</a>：在这个网站内搜索：网站/app +爬虫 这个关键词，在站内搜索</li><li><a href="https://link.zhihu.com/?target=https%3A//juejin.im/" target="_blank" rel="noopener">掘金</a>：在这个网站内搜索：网站/app +爬虫 这个关键词，在站内搜索</li></ul><p>排名不分先后</p><p><strong>七，各大公司的财报</strong></p><p>通常对于上市公司来说，财报信息包含的内容是最全面的，关于用户，商业，渠道，增长，业务策略等等。所以如果想了解一个公司，如果是上市公司最好第一手先看财报后者SEC（上市报告）。</p><p>很多同学问我财报哪里找，不知道怎么看。其实每个公司都有自己的IR（投资者页面），在上面有财报的完整的pdf下载。另外，也推荐大家听听每期的企业conference call（回答财报问题），可以听下CEO对财报的解读。</p><p>这里我列举几个大公司财报的网站，</p><p><a href="https://link.zhihu.com/?target=https%3A//www.wind.com.cn/NewSite/edb.html" target="_blank" rel="noopener">wind</a>：金融数据库，包含财报和行业信息</p><p>百度财报 PDF：<a href="https://link.zhihu.com/?target=http%3A//ir.baidu.com/phoenix.zhtml%3Fc%3D188488%26p%3Dirol-irhome" target="_blank" rel="noopener">Baidu | Investors | Home</a></p><p><a href="https://link.zhihu.com/?target=http%3A//ir.baidu.com/phoenix.zhtml%3Fc%3D188488%26p%3Dirol-presentations" target="_blank" rel="noopener">百度财报解读podcast</a>：音频可以在线听</p><p>阿里财报pdf：<a href="https://link.zhihu.com/?target=https%3A//www.alibabagroup.com/cn/ir/earnings" target="_blank" rel="noopener">阿里巴巴集团</a></p><p>腾讯财报pdf：<a href="https://link.zhihu.com/?target=http%3A//www.tencent.com/zh-cn/investor.html" target="_blank" rel="noopener">Tencent 腾讯 - 投资者关系</a></p><p>搜狐财报pdf：<a href="https://link.zhihu.com/?target=http%3A//investors.sohu.com/" target="_blank" rel="noopener">http://investors.sohu.com/</a></p><p>拼多多pdf：<a href="https://link.zhihu.com/?target=http%3A//investor.pinduoduo.com/news-releases" target="_blank" rel="noopener">Investor Relations | Pinduoduo Inc.</a></p><p><a href="https://link.zhihu.com/?target=https%3A//edge.media-server.com/m6/p/sgasimfp" target="_blank" rel="noopener">拼多多财报解读</a>：音频可以在线听。</p><p>如果大家有自己想要了解的公司，在百度or google搜索：公司名字+IR ，可以 定位到他们公司的财报网站页面。在页面上找到conference call或者webcast，可以 找到他们的财报解读音频。</p><p><strong>八，投资机构的统计网站（创业方向选择，投融资选择的时候用）</strong></p><ol><li><p><a href="https://link.zhihu.com/?target=https%3A//www.itjuzi.com/" target="_blank" rel="noopener">IT桔子 | IT互联网公司产品数据库及商业信息服务</a>（IT桔子，中国创业公司投融资数据和报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.chinaventure.com.cn/cmsmodel/report/list.shtml" target="_blank" rel="noopener">研究院_ChinaVenture投资中国网</a>-（投中的每个季度的行业融资报告，不定期有专项分析报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.cbinsights.com/blog/" target="_blank" rel="noopener">CB Insights - Blog</a> （CBI insights的一系列产品，包括公司的估值，独角兽公司列表等）</p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.cbinsights.com/research-downround-tracker" target="_blank" rel="noopener">The Downround Tracker</a>（公司估值下降的趋势）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.cbinsights.com/research-unicorn-companies" target="_blank" rel="noopener">The Complete List of Unicorn Companies</a>（独角兽公司列表）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.renaissancecapital.com/ipohome/marketwatch.aspx" target="_blank" rel="noopener">IPO Center: IPO Market, IPO News, IPO Calendars, IPO Pricings, IPO Voting</a>（IPO相关新闻和趋势报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.privco.com/dashboard" target="_blank" rel="noopener">PrivCo | Private Company Financial Intelligence</a>（美国金融数据公司，主要关注未上市公司的所有投融资资料，目前涵盖的公司包括全世界，当然也包括中国公司）  </p></li><li><p>券商<a href="https://link.zhihu.com/?target=http%3A//data.eastmoney.com/report/hyyb.html%23dHA9MCZjZz0wJmR0PTImaHk9NDQ3JnBhZ2U9MQ%3D%3D" target="_blank" rel="noopener">行业研究报告</a> （国内券商的行业报告，策略报告，可以筛选行业，筛选报告类型）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//pitchbook.com/news/reports" target="_blank" rel="noopener">https://pitchbook.com/news/reports</a>（PitchBook的PE,VC，M&amp;A行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.chinaventure.com.cn/cmsmodel/report/study/count/list.shtml" target="_blank" rel="noopener">研究院_ChinaVenture投资中国网</a> （IPO 投融资行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.dowjones.com/press-room/dow-jones-venturesource-2q16-u-s-venture-capital-report/" target="_blank" rel="noopener">Dow Jones VentureSource 2Q’16 U.S. Venture Capital Report</a>（道琼斯旗下机构Dow Jones LP Source行业投资报告）  </p></li><li><p>NVCA <a href="https://link.zhihu.com/?target=http%3A//nvca.org/research/venture-investment/" target="_blank" rel="noopener">Venture Investment</a>（美国国家风险投资协会，每个季度和年度都会出投融资行业报告）  </p></li><li><p>PWC-<a href="https://link.zhihu.com/?target=https%3A//www.pwcmoneytree.com/" target="_blank" rel="noopener">MoneyTree Home</a>（PWC的money tree report是每个季度美国的风险投资行业报告）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//home.kpmg.com/xx/en/home/insights.html" target="_blank" rel="noopener">https://home.kpmg.com/xx/en/home/insights.html</a> （KPMG毕马威的insights报告，一般是每个季度的创投趋势，比较细致的分析）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//mattermark.com//" target="_blank" rel="noopener">Mattermark - Discover, Enrich, &amp; Analyze Companies</a>（创业公司投资并购信息一站式搜索）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//pitchbook.com/" target="_blank" rel="noopener">M&amp;A, Private Equity &amp; Venture Capital Database</a>（创业公司投资并购信息一站式搜索）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.datafox.com/" target="_blank" rel="noopener">DataFox | Prospect Sales Leads with Company Signals</a>（创业公司投资并购信息一站式搜索）  </p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.crunchbase.com/%23/home/index" target="_blank" rel="noopener">CrunchBase accelerates innovation by bringing together data on companies and the people behind them.</a>（创业公司数据库）  </p></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.ventureintelligence.com/" target="_blank" rel="noopener">Venture Intelligence</a> PE/VC database</p></li><li><a href="https://link.zhihu.com/?target=https%3A//seekingalpha.com/" target="_blank" rel="noopener">Stock Market Insights | Seeking Alpha</a> （二级市场金融分析网站）</li><li><a href="https://link.zhihu.com/?target=http%3A//www.trefis.com/modeldemo/institutional/22340/Qpiyk/0700.HK%3FeasyAccessToken%3DPROVIDER_cf15b6285eebd7b94e7c2aa257b8c75161ce8a8c" target="_blank" rel="noopener">Tencent Holdings Ltd – Trefis</a>（各个公司的revenue model的预测和key driver的趋势，这个网站简直不能再棒）  </li></ol><p><img src="https://pic2.zhimg.com/50/5d804a3a242cf5174f6679c148d180fb_hd.jpg" alt></p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;946&#39; height=&#39;474&#39;&gt;&lt;/svg" alt></p><p>排名不分先后</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/12/14/r/r-chang-yong-fang-fa/"/>
      <url>/2019/12/14/r/r-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="R语言使用中的一些奇技淫巧"><a href="#R语言使用中的一些奇技淫巧" class="headerlink" title="R语言使用中的一些奇技淫巧"></a>R语言使用中的一些奇技淫巧</h2><h3 id="1-读取excel内存溢出"><a href="#1-读取excel内存溢出" class="headerlink" title="1 读取excel内存溢出"></a>1 读取excel内存溢出</h3><pre><code>    #下载包    install.packages(&quot;openxlsx&quot;)    #读取openxlsx包    library(openxlsx)    file&lt;-read.xlsx(&quot;Z:\\-2019\\周报\\2019.6.24\\6.21库存.xlsx&quot;,1)</code></pre><h3 id="字段筛选"><a href="#字段筛选" class="headerlink" title="字段筛选"></a>字段筛选</h3><pre><code>data&lt;-file[c(2:7,15,25,26,29)]</code></pre><h3 id="将文本变为同名字符串"><a href="#将文本变为同名字符串" class="headerlink" title="将文本变为同名字符串"></a>将文本变为同名字符串</h3><pre><code>test&lt;-c(1,2,3,4,5)nameTest&lt;-substitute(test)</code></pre><p>#多条件字段内容删选  选出产品分类中：赠品、产品目录、其他 另存新表</p><pre><code>tichu&lt;-data[which((start_data$产品分类==&quot;赠品&quot;)|(start_data$产品分类==&quot;产品目录&quot;)|(start_data$产品分类==&quot;其他&quot;)),]#查看饰品中是否有较多库存  &gt;= 30 有就也剔除#使用该方法是因为 &gt;=30  的时候符合该条件的情况为0  就会导出删选出错  所以使用以下方法shipin&lt;-which((kucun$产品分类==&quot;饰品&quot;)&amp;(as.integer(kucun$可销库存)&gt;=30))if(length(shipin)&gt;0){  kucun&lt;-kucun[-shipin,]}</code></pre><h3 id="使用数据透视表方法-用sql实现"><a href="#使用数据透视表方法-用sql实现" class="headerlink" title="使用数据透视表方法  用sql实现"></a>使用数据透视表方法  用sql实现</h3><pre><code>library(sqldf)result&lt;-(sqldf(&#39;select &quot;产品名称&quot;,&quot;产品分类&quot;, count(&quot;产品名称&quot;),sum(可销库存),sum(&quot;7天销量&quot;),sum(&quot;30天销量&quot;),sum(&quot;昨日销量&quot;) from CC group by &quot;产品名称&quot;&#39;))</code></pre><p>#excel中时间处理</p><p>excel 中起始时间为  1900-01-01   Excel把1900年当做闰年，计算了2月29日  所以r转化差两天  origin=”1899-12-30”</p><p>r语言 中起始时间为 1970-01-01 origin = “1970-01-01”</p><p><a href="https://support.microsoft.com/en-us/help/214326/excel-incorrectly-assumes-that-the-year-1900-is-a-leap-year" target="_blank" rel="noopener">https://support.microsoft.com/en-us/help/214326/excel-incorrectly-assumes-that-the-year-1900-is-a-leap-year</a></p><h1 id="将上新时间修复-异常的置空"><a href="#将上新时间修复-异常的置空" class="headerlink" title="将上新时间修复  异常的置空"></a>将上新时间修复  异常的置空</h1><pre><code>Online_Time$上新时间&lt;-as.Date(as.integer(Online_Time$上新时间),origin=&quot;1899-12-30&quot;)as.Date(Online_Time[,1],origin = &quot;1970-01-01&quot;)</code></pre><h1 id="两个数据表连接"><a href="#两个数据表连接" class="headerlink" title="两个数据表连接"></a>两个数据表连接</h1><pre><code>library(&quot;dplyr&quot;)process&lt;-left_join(result,Online_Time,by=&quot;款号&quot;)[1:8]</code></pre><p>#将数据分sheet写出</p><pre><code>#构造数据listlist_data &lt;- list(&quot;原数据&quot; = data, &quot;剔除&quot; = tichu )#定义一个储存路径path=&quot;Z:\\-2019\\周报\\2019.6.24\\库存清洗_20190621.xlsx&quot;#写出write.xlsx(list_data, file = path)</code></pre><p>#数字以逗号分隔 先替换在转换 gsub(“,”,””, tianmao$支付金额)</p><p>  tianmao$支付金额&lt;-as.numeric(gsub(“,”,””, tianmao$支付金额))</p><h1 id="计算商品名称中包含预售的支付金额-求和"><a href="#计算商品名称中包含预售的支付金额-求和" class="headerlink" title="计算商品名称中包含预售的支付金额  求和"></a>计算商品名称中包含预售的支付金额  求和</h1><pre><code>yuhsou&lt;-sum(tianmao[grep(pattern=&quot;预售&quot;,tianmao$商品名称),&quot;支付金额&quot;])调整输出小数位数  options(digits=4)</code></pre><h1 id="超级好用的字符串处理包"><a href="#超级好用的字符串处理包" class="headerlink" title="超级好用的字符串处理包"></a>超级好用的字符串处理包</h1><pre><code>library(stringr)#取出商品名中的款号  例：PT616kuanhao&lt;-str_extract_all(tianmao[1:20,&quot;商品名称&quot;],&quot;[A-Z]+[0-9]+&quot;)[]</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反扒措施</title>
      <link href="/2019/06/14/pa-chong/fan-ba-cuo-shi/"/>
      <url>/2019/06/14/pa-chong/fan-ba-cuo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫常见反扒措施"><a href="#爬虫常见反扒措施" class="headerlink" title="爬虫常见反扒措施"></a>爬虫常见反扒措施</h2><p>在互联网上爬取数据的过程中难免出现ip被封或者服务器返回403等等，这可能是你被网站检测为爬虫而采取的反爬措施，本文主要总结了一些常见的情况及规避的措施。</p><h3 id="构造合理的请求头"><a href="#构造合理的请求头" class="headerlink" title="构造合理的请求头"></a>构造合理的请求头</h3><p>HTTP 的请求头是在你每次向网络服务器发送请求时，传递的一组属性和配置信息。HTTP 定义了十几种古怪的请求头类型，不过大多数都不常用。<br>较为常用的是 <code>Cookie</code>  <code>User-Agent</code>。尤其是<code>User-Agent</code>，这个没有大多数网站是请求不到的，<code>Cookie</code>中包含了你的登录信息。</p><pre><code>from fake_useragent import UserAgentheaders = {            &#39;Cookie&#39;:&#39;&#39; ,            &#39;User-Agent&#39;: user_agent.random            }</code></pre><p>另外，请求头还可能让网站改变内容的布局样式。例如，用移动设备浏览网站时，通常会看到一个没有广告、Flash以及其他干扰的简化的网站版本。因此，把你的请求头User-Agent改成下面这样，也许就可以看到一个更容易采集的网站了。</p><p><code>User-Agent:Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) App leWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53</code></p><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>使用代理也是一种较为常见的方法，使用方法较为简单，只是使用前一定有确定ip可用。</p><pre><code>    import requests    proxies = {        &quot;http&quot;: &quot;XXX.XX.XX.XX:XX&quot;,    }    print requests.get(&#39;http://www.ip181.com/&#39;,proxies=proxies).content</code></pre><p><a href="http://www.xdaili.cn/monitor" title="http://www.xdaili.cn/monitor" target="_blank" rel="noopener">http://www.xdaili.cn/monitor</a> 是一个可以检测代理IP的网站，它可以检测出你使用的ip是什么，正好可以用来检验自己是否使用代理ip成功。如果你有多个代理IP，那么可以建立一个IP池，每次随机从IP池中选择一个进行访问，如果访问失败了，则将其从池中去除即可。</p><h3 id="图形验证码的识别"><a href="#图形验证码的识别" class="headerlink" title="图形验证码的识别"></a>图形验证码的识别</h3><ol><li><p>直接将图片识别</p><pre><code> import tesserocr from PIL import Image image = Image.open(&#39;code2.jpg&#39;) result = tesserocr.image_to_text(image) print(result)</code></pre></li><li><p>将图片进行简单处理后识别，正确率较高</p><pre><code> import tesserocr from PIL import Image image = Image.open(&#39;code2.jpg&#39;) #向量化处理图片  方便识别 image = image.convert(&#39;L&#39;) #调整阈值 threshold = 127 table = [] for i in range(256):     if i &lt; threshold:         table.append(0)     else:         table.append(1) image = image.point(table, &#39;1&#39;) image.show() result = tesserocr.image_to_text(image) print(result)</code></pre></li><li><p>示例操作</p><pre><code> import tesserocr from PIL import Image def get_image():     #将网页截屏     browser.save_screenshot(&#39;jietu.png&#39;)     #找到验证码位置     img=browser.find_element_by_id(&quot;chkimg&quot;)     #获取验证码x,y轴坐标     location = img.location #     print(location)     #获取验证码的长宽     size =img.size     #写成我们需要截取的位置坐标     left = location[&#39;x&#39;]     top = location[&#39;y&#39;]     right = left + size[&#39;width&#39;]     bottom = top + size[&#39;height&#39;]     #打开截图     i=Image.open(&quot;jietu.png&quot;)     #使用Image的crop函数，从截图中再次截取我们需要的区域     image_obj =i.crop((left, top, right, bottom))     image_obj.save(&#39;yzm.png&#39;)     image=Image.open(&#39;yzm.png&#39;)     #向量化处理图片  方便识别     image=image.convert(&quot;L&quot;)     #调整阈值     threshold=80     table=[]     for i in range(256):         if i &lt;threshold:             table.append(0)         else:             table.append(1)     image=image.point(table,&#39;1&#39;) #     image.show()  将图片显示出来     #识别     yzm=tesserocr.image_to_text(image)     yzm=yzm.strip() #剔除空格     #清空验证码输入框     browser.find_element_by_id(&quot;verifyCode&quot;).clear()     #将验证码填入     browser.find_element_by_id(&quot;verifyCode&quot;).send_keys(yzm)</code></pre></li></ol><h3 id="模拟滑块"><a href="#模拟滑块" class="headerlink" title="模拟滑块"></a>模拟滑块</h3><ol><li><p>下面的代码仅使用于需要拖到底的验证码滑块。</p><pre><code> swipe_button = self.browser.find_element_by_id(&#39;nc_1_n1z&#39;) #获取滑动拖动控件 #模拟拽托 action = ActionChains(self.browser) # 实例化一个action对象   action.click_and_hold(swipe_button).perform() # perform()用来执行ActionChains中存储的行为 action.reset_actions() action.move_by_offset(580, 0).perform() # 移动滑块</code></pre></li><li><p>需要拼接的滑块验证码</p></li></ol><p>大致分为以下几个步骤：  </p><ol><li><p>步骤一:点击按钮，弹出没有缺口的图片</p></li><li><p>步骤二：获取步骤一的图片</p></li><li><p>步骤三：点击滑动按钮，弹出带缺口的图片</p></li><li><p>步骤四：获取带缺口的图片</p></li><li><p>步骤五：对比两张图片的所有RBG像素点，得到不一样像素点的x值，即要移动的距离</p></li><li><p>步骤六：模拟人的行为习惯（先匀加速拖动后匀减速拖动），把需要拖动的总距离分成一段一段小的轨迹</p></li><li><p>步骤七：按照轨迹拖动，完全验证</p></li><li><p>步骤八：完成登录</p></li></ol><p>代码较长就不贴出来了</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/sanduzxcvbnm/p/10341689.html" target="_blank" rel="noopener">极验滑动验证码的识别</a></li><li><a href="https://www.cnblogs.com/caoxing2017/p/8311036.html" target="_blank" rel="noopener">破解极验滑动验证码</a></li><li><a href="https://www.cnblogs.com/beer/p/7808043.html" target="_blank" rel="noopener">初级的滑动式验证图片识别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium的使用</title>
      <link href="/2019/06/10/pa-chong/selenium-de-shi-yong/"/>
      <url>/2019/06/10/pa-chong/selenium-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="Selenium的使用"><a href="#Selenium的使用" class="headerlink" title="Selenium的使用"></a>Selenium的使用</h2><h3 id="一、什么是Selenium"><a href="#一、什么是Selenium" class="headerlink" title="一、什么是Selenium"></a>一、什么是Selenium</h3><p>selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。</p><p>selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。</p><h3 id="二、selenium基本使用"><a href="#二、selenium基本使用" class="headerlink" title="二、selenium基本使用"></a>二、selenium基本使用</h3><h4 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h4><p>selenium支持很多的浏览器，但是如果想要声明并调用浏览器则需要：</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()</code></pre><p>这里只写了两个例子，当然了其他的支持的浏览器都可以通过这种方式调用</p><h4 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h4><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;http://www.baidu.com&quot;) print(browser.page_source)browser.close() </code></pre><p>上述代码运行后，会自动打开Chrome浏览器，并登陆百度打印百度首页的源代码，然后关闭浏览器</p><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p><strong>单个元素查找</strong></p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;http://www.taobao.com&quot;)input_first = browser.find_element_by_id(&quot;q&quot;)input_second = browser.find_element_by_css_selector(&quot;#q&quot;)input_third = browser.find_element_by_xpath(&#39;//*\[@id=&quot;q&quot;\]&#39;) print(input_first) print(input_second) print(input_third)browser.close()</code></pre><p>这里我们通过三种不同的方式去获取响应的元素，第一种是通过id的方式，第二个中是CSS选择器，第三种是xpath选择器，结果都是相同的。<br>结果如下：</p><p>这里列举一下常用的查找元素方法：</p><pre><code>find_element_by_name  find_element_by_id  find_element_by_xpath  find_element_by_link_text  find_element_by_partial_link_text  find_element_by_tag_name  find_element_by_class_name  find_element_by_css_selector    </code></pre><p>下面这种方式是比较通用的一种方式：这里需要记住By模块所以需要导入  </p><pre><code>from selenium.webdriver.common.by import Byfrom selenium import webdriver from selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&quot;http://www.taobao.com&quot;)input_first = browser.find_element(By.ID,&quot;q&quot;) print(input_first)browser.close()</code></pre><p>当然这种方法和上述的方式是通用的，browser.find_element(By.ID,”q”)这里By.ID中的ID可以替换为其他几个</p><p><strong>多个元素查找</strong></p><p>其实多个元素和单个元素的区别，举个例子：find_elements,单个元素是find_element,其他使用上没什么区别，通过其中的一个例子演示：</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;http://www.taobao.com&quot;)lis = browser.find_elements_by_css_selector(&#39;.service-bd li&#39;) print(lis)browser.close()</code></pre><p>这样获得就是一个列表</p><p>当然上面的方式也是可以通过导入from selenium.webdriver.common.by import By 这种方式实现</p><p>lis = browser.find_elements(By.CSS_SELECTOR,’.service-bd li’)</p><p>同样的在单个元素中查找的方法在多个元素查找中同样存在：  </p><pre><code>find_elements_by_name  find_elements_by_id  find_elements_by_xpath  find_elements_by_link_text  find_elements_by_partial_link_text  find_elements_by_tag_name  find_elements_by_class_name  find_elements_by_css_selector</code></pre><h4 id="元素交互操作"><a href="#元素交互操作" class="headerlink" title="元素交互操作"></a>元素交互操作</h4><p>对于获取的元素调用交互方法</p><pre><code>from selenium import webdriver import timebrowser = webdriver.Chrome()browser.get(&quot;http://www.taobao.com&quot;)input_str = browser.find_element_by_id(&#39;q&#39;)input_str.send_keys(&quot;ipad&quot;)time.sleep(1)input_str.clear() #清除文本框内容input_str.send_keys(&quot;MakBook pro&quot;) #输入文本 button = browser.find_element_by_class_name(&#39;btn-search&#39;)button.click() # 模拟点击</code></pre><p>运行的结果可以看出程序会自动打开Chrome浏览器并打开淘宝输入ipad,然后删除，重新输入MakBook pro，并点击搜索</p><h4 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h4><p>这是一个非常有用的方法，这里就可以直接调用js方法来实现一些操作，<br>下面的例子是通过登录知乎然后通过js翻到页面底部，并弹框提示</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;http://www.zhihu.com/explore&quot;)browser.execute_script(&#39;window.scrollTo(0, document.body.scrollHeight)&#39;)browser.execute_script(&#39;alert(&quot;To Bottom&quot;)&#39;)</code></pre><p><strong>获取元素属性</strong>  </p><p>get_attribute(‘class’)</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()url = &#39;https://www.zhihu.com/explore&#39; browser.get(url)logo = browser.find_element_by_id(&#39;zh-top-link-logo&#39;) print(logo) print(logo.get_attribute(&#39;class&#39;))</code></pre><p><strong>获取文本值</strong><br>.text</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()url = &#39;https://www.zhihu.com/explore&#39; browser.get(url)input = browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input.text)</code></pre><p><strong>获取ID，位置，标签名</strong><br>id<br>location<br>tag_name<br>size</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()url = &#39;https://www.zhihu.com/explore&#39; browser.get(url)input = browser.find_element_by_class_name(&#39;zu-top-add-question&#39;) print(input.id) print(input.location) print(input.tag_name) print(input.size)</code></pre><h4 id="浏览器的前进和后退"><a href="#浏览器的前进和后退" class="headerlink" title="浏览器的前进和后退"></a>浏览器的前进和后退</h4><p>back()  后退</p><p>forward()  前进</p><pre><code>import time from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.baidu.com/&#39;)browser.get(&#39;https://www.taobao.com/&#39;)browser.get(&#39;https://www.hao123.com/&#39;)browser.back() #后退time.sleep(1)browser.forward()# 前进browser.close()</code></pre><h4 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h4><pre><code>get_cookies()  delete_all_cookes()  add_cookie()from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.zhihu.com/explore&#39;) print(browser.get_cookies())browser.add_cookie({&#39;name&#39;: &#39;name&#39;, &#39;domain&#39;: &#39;www.zhihu.com&#39;, &#39;value&#39;: &#39;zhaofan&#39;}) print(browser.get_cookies())browser.delete_all_cookies() print(browser.get_cookies())</code></pre><h4 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h4><pre><code>import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.baidu.com&#39;)browser.execute_script(&#39;window.open()&#39;)#打开新窗口print(browser.window_handles)#输出窗口信息browser.switch_to.window(browser.window_handles[1])#切换窗口browser.get(&#39;https://www.taobao.com&#39;)#在当前窗口打开新页面time.sleep(1)browser.switch_to.window(browser.window_handles[0])#切换窗口browser.close()#多标签页下  关闭当前标签页  只有一个标签则关闭并退出浏览器browser.quit()#退出浏览器</code></pre><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>这里的异常比较复杂，官网的参考地址：<br><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions" target="_blank" rel="noopener">http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions</a><br>这里只进行简单的演示，查找一个不存在的元素</p><pre><code>from selenium import webdriver from selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser = webdriver.Chrome() try:    browser.get(&#39;https://www.baidu.com&#39;) except TimeoutException: print(&#39;Time Out&#39;) try:    browser.find_element_by_id(&#39;hello&#39;) except NoSuchElementException:     print(&#39;No Element&#39;) finally:    browser.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL储存</title>
      <link href="/2019/06/04/pa-chong/mysql-chu-cun/"/>
      <url>/2019/06/04/pa-chong/mysql-chu-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫MYSQL储存"><a href="#爬虫MYSQL储存" class="headerlink" title="爬虫MYSQL储存"></a>爬虫MYSQL储存</h2><h3 id="一、连接并创建数据库"><a href="#一、连接并创建数据库" class="headerlink" title="一、连接并创建数据库"></a>一、连接并创建数据库</h3><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306)cursor = db.cursor()cursor.execute(&#39;SELECT VERSION()&#39;)data = cursor.fetchone()print(&#39;Database version:&#39;, data)cursor.execute(&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8&quot;)db.close()</code></pre><p>执行结果：</p><pre><code>Database version: (&#39;8.0.15&#39;,)</code></pre><p>结果是创建一个名为spiders的数据库</p><h3 id="二、创建数据表"><a href="#二、创建数据表" class="headerlink" title="二、创建数据表"></a>二、创建数据表</h3><p>注意：这次连接数据库时需要指定创建数据表所在的数据库，也就是db参数的值</p><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306, db=&#39;spiders&#39;)cursor = db.cursor()sql = &#39;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))&#39;cursor.execute(sql)db.close()</code></pre><h3 id="三、插入一条数据"><a href="#三、插入一条数据" class="headerlink" title="三、插入一条数据"></a>三、插入一条数据</h3><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306, db=&#39;spiders&#39;)cursor = db.cursor()id = &#39;20120001&#39;user = &#39;Bob&#39;age = 20sql = &#39;INSERT INTO students(id, name, age) values(%s, %s, %s)&#39;try:    cursor.execute(sql, (id, user, age))    db.commit()except:    db.rollback()db.close()</code></pre><p><strong>通用写法：</strong></p><p>推荐使用：这样一来，若是写入更多值的话直接给data字典增加数据就行了，就不用其他sql语句了</p><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306, db=&#39;spiders&#39;)cursor = db.cursor()table = &#39;students&#39;data = {    &#39;id&#39;: &#39;20120002&#39;,    &#39;name&#39;: &#39;Bob11&#39;,    &#39;age&#39;: 200}keys = &#39;, &#39;.join(data.keys())values = &#39;, &#39;.join([&#39;%s&#39;] * len(data))sql = &#39;INSERT INTO {table} ({keys}) VALUES ({values})&#39;.format(table=table, keys=keys, values=values)try:    if cursor.execute(sql, tuple(data.values())):        print(&#39;Successful&#39;)        db.commit()except:    print(&#39;Failed&#39;)    db.rollback()db.close()</code></pre><h3 id="四、更新数据"><a href="#四、更新数据" class="headerlink" title="四、更新数据"></a>四、更新数据</h3><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306, db=&#39;spiders&#39;)cursor = db.cursor()sql = &#39;UPDATE students SET age = %s WHERE name = %s&#39;try:   cursor.execute(sql, (25, &#39;Bob&#39;))   db.commit()except:   db.rollback()db.close()</code></pre><p><strong>通用写法：</strong></p><p>根据主键进行判断，若主键存在则更新，若不存在则插入，推荐使用</p><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306, db=&#39;spiders&#39;)cursor = db.cursor()table = &#39;students&#39;data = {    &#39;id&#39;: &#39;20120001&#39;,    &#39;name&#39;: &#39;Bob&#39;,    &#39;age&#39;: 21}keys = &#39;, &#39;.join(data.keys())values = &#39;, &#39;.join([&#39;%s&#39;] * len(data))sql = &#39;INSERT INTO {table}({keys}) VALUES ({values}) ON DUPLICATE KEY UPDATE&#39;.format(table=table, keys=keys,                                                                                     values=values)update = &#39;,&#39;.join([&quot; {key} = %s&quot;.format(key=key) for key in data])sql += updatetry:    if cursor.execute(sql, tuple(data.values()) * 2):        print(&#39;Successful&#39;)        db.commit()except:    print(&#39;Failed&#39;)    db.rollback()db.close()</code></pre><h3 id="五、查询数据"><a href="#五、查询数据" class="headerlink" title="五、查询数据"></a>五、查询数据</h3><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306, db=&#39;spiders&#39;)cursor = db.cursor()sql = &#39;SELECT * FROM students WHERE age &gt;= 20&#39;try:    cursor.execute(sql)    print(&#39;Count:&#39;, cursor.rowcount)    row = cursor.fetchone()    while row:        print(&#39;Row:&#39;, row)        row = cursor.fetchone()except:    print(&#39;Error&#39;)</code></pre><h3 id="六、删除数据"><a href="#六、删除数据" class="headerlink" title="六、删除数据"></a>六、删除数据</h3><pre><code>import pymysqldb = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, port=3306, db=&#39;spiders&#39;)cursor = db.cursor()table = &#39;students&#39;condition = &#39;age &gt; 20&#39;sql = &#39;DELETE FROM  {table} WHERE {condition}&#39;.format(table=table, condition=condition)try:    cursor.execute(sql)    db.commit()except:    db.rollback()db.close()</code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在一般的生成环境中，通常是先在MYSQL中先建好表，再将数据一条一条的插入进去，下面为一些语句解释。</p><pre><code>import pymysql# 打开数据库连接        “地址      用户名    密码       数据库        编码”db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;spiders&quot;, charset=&#39;utf8&#39; )# 使用cursor()方法获取操作游标 cursor = db.cursor()# 使用execute方法执行SQL语句cursor.execute(&quot;SELECT VERSION()&quot;)# 使用 fetchone() 方法获取一条数据data = cursor.fetchone()print(&quot;Database version : %s &quot; % data) # 关闭数据库连接db.close()</code></pre><p><a href="https://www.runoob.com/python3/python3-mysql.html" target="_blank" rel="noopener">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据文件储存</title>
      <link href="/2019/06/02/pa-chong/shu-ju-chi-jiu-hua/"/>
      <url>/2019/06/02/pa-chong/shu-ju-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="数据文件储存"><a href="#数据文件储存" class="headerlink" title="数据文件储存"></a>数据文件储存</h2><p>数据文件存储形式可以是多种多样的，比如可以保存成 TXT 纯文本形式，也可以保存为 Json 格式、CSV 格式等，本节我们来了解下文本文件的存储方式。</p><h3 id="TXT文本存储"><a href="#TXT文本存储" class="headerlink" title="TXT文本存储"></a>TXT文本存储</h3><p>将数据保存到 TXT 文本的操作非常简单，而且 TXT 文本几乎兼容任何平台，但是有个缺点就是不利于检索，所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用 TXT 文本存储，本节我们来看下利用 Python 保存 TXT 文本文件的方法。  </p><ol><li><p>本节目标</p><p> 本节我们要保存知乎发现页面的热门问题部分，将其问题和答案统一保存成文本形式。</p></li><li><p>基本实例</p><p> 首先可以用 Requests 将网页源代码获取下来，然后使用 PyQuery 解析库进行解析，接下来将提取的标题、回答者、回答保存到文本，代码如下：</p><pre><code> import requests         from pyquery import PyQuery as pq          url = &#39;https://www.zhihu.com/explore&#39;         headers = {             &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#39;     } html = requests.get(url, headers=headers).text doc = pq(html) items = doc(&#39;.explore-tab .feed-item&#39;).items() for item in items:     question = item.find(&#39;h2&#39;).text()     author = item.find(&#39;.author-link-line&#39;).text()     answer = pq(item.find(&#39;.content&#39;).html()).text()     file = open(&#39;explore.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;)     file.write(&#39;\n&#39;.join([question, author, answer]))     file.write(&#39;\n&#39; + &#39;=&#39; * 50 + &#39;\n&#39;)     file.close()</code></pre><p> 在这里主要是为了演示文件保存的方式，因此 Requests 异常处理部分在此省去，我们首先用 Requests 提取了知乎发现页面，然后将热门问题的问题、回答者、答案全文提取出来，然后利用了Python提供的 open() 方法打开一个文本文件，获取一个文件操作对象，这里赋值为 file，然后利用 file 对象的 write() 方法将提取的内容写入文件，最后记得调用一下 close() 方法将其关闭，这样抓取的内容即可成功写入到文本中了。  </p><p> 运行程序，可以发现在本地生成了一个 explore.txt 文件，这样热门问答的内容就被保存文文本形式了。</p><p> 在这里 open() 方法的第一个参数即为要保存的目标文件名称，第二个参数为 a，代表以追加方式写入到文本，另外我们还指定了文件的编码为utf-8，最后写入完成之后，我们还需要调用 close() 方法来关闭文件对象。</p></li><li><p>打开方式</p><p> 在刚才的实例中，第二个参数我们设置成了 a，这样在每次写入文本时不会清空源文件，而是在文件末尾写入新的内容，这是一种文件打开方式。关于文件打开方式，其实还有另外的几种，在此列举如下：</p><blockquote><p>r　　以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br>rb　 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。<br>r+　 打开一个文件用于读写。文件指针将会放在文件的开头。<br>rb+　以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。<br>w　　打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>wb　 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>w+　 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>wb+　以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>a　　打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>ab 　以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>a+　打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>ab+　以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。  </p></blockquote></li><li><p>简化写法</p><p> 另外文件写入还有一种简写方法，那就是使用 with as 语法，在 with 控制块结束时，文件会自动关闭，所以就不需要再调用 close() 方法了。</p><p> 所以上面的保存方式我们可以简写如下：</p><pre><code> with open(&#39;explore.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as file:     file.write(&#39;\n&#39;.join([question, author, answer]))     file.write(&#39;\n&#39; + &#39;=&#39; * 50 + &#39;\n&#39;)</code></pre><p> 如果想保存时将原文清空，那么可以将第二个参数改写为 w，代码如下：</p><pre><code> with open(&#39;explore.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:         file.write(&#39;\n&#39;.join([question, author, answer]))         file.write(&#39;\n&#39; + &#39;=&#39; * 50 + &#39;\n&#39;)</code></pre><p> 如果数据结构为[{},{}…]这种格式的就需要将文本转换一下，再写出</p><pre><code> for row in student_list_info:     for txt in row.values():         rstr += str(txt) + &#39;\t&#39;     rstr += &#39;\n&#39; with open(&#39;students_txt.txt&#39;, &#39;a+&#39;, encoding=&#39;utf8&#39;) as f:     f.write(rstr)</code></pre></li></ol><h3 id="Json文件存储"><a href="#Json文件存储" class="headerlink" title="Json文件存储"></a>Json文件存储</h3><p>Json，全称为 JavaScript Object Notation, 也就是 JavaScript 对象标记，通过对象和数组的组合来表示数据，构造简洁但是结构化程度非常高，它是一种轻量级的数据交换格式，本节我们来了解一下利用 Python 保存数据到 Json 文件的方法。</p><ol><li><p>对象和数组</p><p> 在 JavaScript 语言中，一切都是对象。因此，任何支持的类型都可以通过 Json 来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型。</p><ul><li>对象<br>  对象在 JavaScript 中是使用花括号 {} 包裹起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。</li><li><p>数组<br>  数组在 JavaScript 中是方括号 [] 包裹起来的内容，数据结构为 [“java”, “javascript”, “vb”, …] 的索引结构。在 JavaScript 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引使用得多。同样，值的类型可以是任意类型。</p><p>所以一个 Json 对象可以写为如下形式：</p><pre><code>  [{      &quot;name&quot;: &quot;Bob&quot;,              &quot;gender&quot;: &quot;male&quot;,              &quot;birthday&quot;: &quot;1992-10-18&quot;  }, {       &quot;name&quot;: &quot;Selina&quot;,              &quot;gender&quot;: &quot;female&quot;,              &quot;birthday&quot;: &quot;1995-10-18&quot;  }]</code></pre><p>由中括号包围的就相当于列表类型，列表的每个元素可以是任意类型，在示例中它是字典类型，由大括号包围。</p><p>Json 可以由以上两种形式自由组合而成，可以无限次嵌套，结构清晰，是数据交换的极佳方式。</p></li></ul></li><li><p>读取Json</p><p> Python 为我们提供了简单易用的 json 库来供我们实现 Json 文件的读写操作，我们可以调用 json 库的 loads() 方法将 Json 文本字符串转为 Json 对象，可以通过 dumps()方法将 Json 对象转为文本字符串。</p><p> 例如在这里有一段 Json 形式的字符串，它是 str 类型，我们用 Python 将可其转换为可操作的数据结构，如列表或字典。</p><pre><code> import json str = &#39;&#39;&#39; [{     &quot;name&quot;: &quot;Bob&quot;,             &quot;gender&quot;: &quot;male&quot;,             &quot;birthday&quot;: &quot;1992-10-18&quot; }, {     &quot;name&quot;: &quot;Selina&quot;,             &quot;gender&quot;: &quot;female&quot;,             &quot;birthday&quot;: &quot;1995-10-18&quot;         }] &#39;&#39;&#39; print(type(str))         data = json.loads(str)         print(data)         print(type(data))</code></pre><p> 运行结果：</p><pre><code> &lt;class &#39;str&#39;&gt; [{&#39;name&#39;: &#39;Bob&#39;, &#39;gender&#39;: &#39;male&#39;, &#39;birthday&#39;: &#39;1992-10-18&#39;}, {&#39;name&#39;: &#39;Selina&#39;, &#39;gender&#39;: &#39;female&#39;, &#39;birthday&#39;: &#39;1995-10-18&#39;}] &lt;class &#39;list&#39;&gt;</code></pre><p> 在这里我们使用了 loads() 方法将字符串转为 Json 对象，由于最外层是中括号，所以最终的类型是列表类型。</p><p> 这样一来我们就可以用索引来取到对应的内容了，例如我们想取第一个元素里的 name 属性，就可以使用如下方式获取：</p><pre><code> data[0][&#39;name&#39;] data[0].get(&#39;name&#39;)</code></pre><p> 得到的结果都是：</p><pre><code> Bob</code></pre><p> 通过中括号加 0 索引我们可以拿到第一个字典元素，然后再调用其键名即可得到相应的键值。在获取键值的时候有两种方式，一种是中括号加键名，另一种是 get() 方法传入键名。推荐使用 get() 方法来获取内容，这样如果键名不存在的话不会报错，会返回None。另外 get() 方法还可以传入第二个参数即默认值，我们用一个示例感受一下：</p><pre><code> data[0].get(&#39;age&#39;) data[0].get(&#39;age&#39;, 25)</code></pre><p> 运行结果：</p><pre><code> None</code></pre><p> 在这里我们尝试获取年龄 age，其实在原字典中是不存在该键名的，如果不存在，默认会返回 None，如果传入第二个参数即默认值，那么在不存在的情况下则返回该默认值。</p><p> 值得注意的是 Json 的数据需要用双引号来包围，不能使用单引号。例如若使用如下形式表示则会出现错误：</p><pre><code> import json     str = &#39;&#39;&#39;     [{         &#39;name&#39;: &#39;Bob&#39;,             &#39;gender&#39;: &#39;male&#39;,         &#39;birthday&#39;: &#39;1992-10-18&#39;         }] &#39;&#39;&#39;         data = json.loads(str)</code></pre><p> 运行结果：</p><pre><code> json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 3 column 5 (char 8)</code></pre><p> 在这里会出现 Json 解析错误的提示，是因为在这里数据用了单括号来包围，请千万注意 Json 字符串的表示需要用双引号，否则 loads() 方法会解析失败。</p><p> 如果我们是从 Json 文本中读取内容，例如在这里有一个data.json 文本文件，其内容是刚才我们所定义的 Json 字符串。</p><p> 我们可以先将文本文件内容读出，然后再利用 loads() 方法转化。</p><pre><code> import json      with open(&#39;data.json&#39;, &#39;r&#39;) as file:     str = file.read()     data = json.loads(str)     print(data)</code></pre><p> 运行结果：</p><pre><code> [{&#39;name&#39;: &#39;Bob&#39;, &#39;gender&#39;: &#39;male&#39;, &#39;birthday&#39;: &#39;1992-10-18&#39;}, {&#39;name&#39;: &#39;Selina&#39;, &#39;gender&#39;: &#39;female&#39;, &#39;birthday&#39;: &#39;1995-10-18&#39;}]</code></pre><p> 以上是读取 Json 文件的方法。</p></li><li><p>输出Json</p><p> 另外我们还可以调用 dumps() 方法来将 Json 对象转化为字符串。</p><p> 例如我们将刚上例中的列表重新写入到文本。</p><pre><code> import json                  data = [{             &#39;name&#39;: &#39;Bob&#39;,         &#39;gender&#39;: &#39;male&#39;,         &#39;birthday&#39;: &#39;1992-10-18&#39; }] with open(&#39;data.json&#39;, &#39;w&#39;) as file:         file.write(json.dumps(data))</code></pre><p> 利用 dumps() 方法我们可以将 Json 对象转为字符串，然后再调用文件的 write() 方法即可写入到文本</p><p> 另外如果我们想保存 Json 的格式，可以再加一个参数 indent，代表缩进字符个数。</p><p> with open(‘data.json’, ‘w’) as file:</p><pre><code> file.write(json.dumps(data, indent=2))</code></pre><p> 这样得到的内容会自动带有缩进，格式会更加清晰。</p><p> 另外如果 Json 中包含中文字符，例如我们将之前的 Json 的部分值改为中文，再用之前的方法写入到文本。</p><pre><code> import json      data = [{     &#39;name&#39;: &#39;王伟&#39;,     &#39;gender&#39;: &#39;男&#39;,     &#39;birthday&#39;: &#39;1992-10-18&#39; }] with open(&#39;data.json&#39;, &#39;w&#39;) as file:             file.write(json.dumps(data, indent=2))</code></pre><p> 为了输出中文，我们还需要指定一个参数 ensure_ascii 为 False，另外规定文件输出的编码。</p><pre><code> with open(&#39;data.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:     file.write(json.dumps(data, indent=2, ensure_ascii=False))</code></pre><p> 这样我们就可以输出 Json 为中文了，所以如果字典中带有中文的内容我们需要设置 ensure_ascii 参数为 False 才可正常写入中文。</p></li></ol><h3 id="CSV文件存储"><a href="#CSV文件存储" class="headerlink" title="CSV文件存储"></a>CSV文件存储</h3><p>CSV，全称叫做 Comma-Separated Values，中文可以叫做逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔，每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符，不过所有记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式，它相比 Excel 文件更加简介，XLS 文本是电子表格，它包含了文本、数值、公式和格式等内容，而 CSV 中不包含这些内容，就是特定字符分隔的纯文本，结构简单清晰，所以有时候我们用 CSV 来保存数据是比较方便的，本节我们来讲解下 Python 读取和写入 CSV 文件的过程。</p><ol><li><p>写入</p><p> 在这里我们先看一个最简单的例子：</p><pre><code> import csv  with open(&#39;data.csv&#39;, &#39;w&#39;) as csvfile:         writer = csv.writer(csvfile)         writer.writerow([&#39;id&#39;, &#39;name&#39;, &#39;age&#39;])             writer.writerow([&#39;10001&#39;, &#39;Mike&#39;, 20])</code></pre><p> 首先打开了一个 data.csv 文件，然后指定了打开的模式为 w，即写入，获得文件句柄，随后调用 csv 库的 writer() 方法初始化一个写入对象，传入该句柄，然后调用 writerow() 方法传入每行的数据即可完成写入。</p><p> 运行结束后会生成一个名为 data.csv 的文件，数据就成功写入了，直接文本形式打开的话内容如下：</p><pre><code> id,name,age 10001,Mike,20 10002,Bob,22 10003,Jordan,21</code></pre><p> 可以看到写入的文本默认是以逗号分隔的，调用一次 writerow() 方法即可写入一行数据</p><p> 实际执行结果：每隔一行都有一个空行，改写成如下形式则没有空行了：</p><p> with open(‘data.csv’, ‘w’,newline=’’) as csvfile:</p><p> 如果我们想修改列与列之间的分隔符可以传入 delimiter 参数，代码如下：</p><p> import csv<br> with open(‘data.csv’, ‘w’) as csvfile:</p><pre><code> writer = csv.writer(csvfile, delimiter=&#39; &#39;) writer.writerow([&#39;id&#39;, &#39;name&#39;, &#39;age&#39;]) writer.writerow([&#39;10001&#39;, &#39;Mike&#39;, 20])</code></pre><p> 例如这里在初始化写入对象的时候传入 delimiter 为空格，这样输出的结果的每一列就是以空格分隔的了，内容如下：</p><pre><code> id name age Mike 20 Bob 22 Jordan 21</code></pre><p> 实际效果：每行的数据都写在第一列了</p><p> 另外我们也可以调用 writerows() 方法同时写入多行，此时参数就需要为二维列表，例如：</p><pre><code> import csv with open(&#39;data.csv&#39;, &#39;w&#39;) as csvfile:     writer = csv.writer(csvfile)     writer.writerow([&#39;id&#39;, &#39;name&#39;, &#39;age&#39;])     writer.writerows([[&#39;10001&#39;, &#39;Mike&#39;, 20], [&#39;10002&#39;, &#39;Bob&#39;, 22], [&#39;10003&#39;, &#39;Jordan&#39;, 21]])</code></pre><p> 输出效果是相同的，内容如下：</p><pre><code> id,name,age 10001,Mike,20 10002,Bob,22 10003,Jordan,21</code></pre><p> 但是一般情况下爬虫爬取的都是结构化数据，我们一般会用字典来表示，在 csv 库中也提供了字典的写入方式，实例如下：</p><pre><code> import csv with open(&#39;data.csv&#39;, &#39;w&#39;) as csvfile:     fieldnames = [&#39;id&#39;, &#39;name&#39;, &#39;age&#39;]     writer = csv.DictWriter(csvfile, fieldnames=fieldnames)     writer.writeheader()     writer.writerow({&#39;id&#39;: &#39;10001&#39;, &#39;name&#39;: &#39;Mike&#39;, &#39;age&#39;: 20})     writer.writerow({&#39;id&#39;: &#39;10002&#39;, &#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 22})     writer.writerow({&#39;id&#39;: &#39;10003&#39;, &#39;name&#39;: &#39;Jordan&#39;, &#39;age&#39;: 21})</code></pre><p> 在这里我们先定义了三个字段，用 fieldnames 表示，然后传给 DictWriter 初始化一个字典写入对象，然后可以先调用 writeheader() 方法先写入头信息，然后再调用 writerow() 方法传入相应字典即可，最终写入的结果是完全相同的，内容如下：</p><pre><code> id,name,age 10001,Mike,20 10002,Bob,22 10003,Jordan,21</code></pre><p> 这样我们就可以完成字典到 CSV 文件的写入了。<br> 另外如果我们想追加写入的话可以修改文件的打开模式，如将 open() 函数的第二个参数改成 a 就可以变成追加写入，代码如下：</p><pre><code> import csv with open(&#39;data.csv&#39;, &#39;a&#39;) as csvfile:     fieldnames = [&#39;id&#39;, &#39;name&#39;, &#39;age&#39;]     writer = csv.DictWriter(csvfile, fieldnames=fieldnames)     writer.writerow({&#39;id&#39;: &#39;10004&#39;, &#39;name&#39;: &#39;Durant&#39;, &#39;age&#39;: 22})</code></pre><p> 这样在上面的基础上再执行这段代码，文件内容便会变成：</p><pre><code> id,name,age 10001,Mike,20 10002,Bob,22 10003,Jordan,21 10004,Durant,22</code></pre><p> 可见数据被追加写入到了文件中。<br> 如果我们要写入中文内容的话可能会遇到字符编码的问题，此时我们需要给 open() 参数指定一个编码格式，比如这里再写入一行包含中文的数据，代码需要改写如下：</p><pre><code> import csv with open(&#39;data.csv&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as csvfile:     fieldnames = [&#39;id&#39;, &#39;name&#39;, &#39;age&#39;]     writer = csv.DictWriter(csvfile, fieldnames=fieldnames)     writer.writerow({&#39;id&#39;: &#39;10005&#39;, &#39;name&#39;: &#39;王伟&#39;, &#39;age&#39;: 22})</code></pre><p> 在这里需要给 open() 函数指定编码，否则可能会发生编码错误。</p><p> 注意：</p><p> 1.指定编码的话,使用文本文档打开csv文件，中文可以显示，但是使用表格打开csv文件中文会乱码</p><p> 2.不指定编码的话，使用文本文档打开csv文件，中文显示乱码，但是使用表格打开csv文件中文会显示</p><p> 以上便是 CSV 文件的写入方法。</p><p> 另外    如果我们接触过 Pandas 等库的话，可以调用 DataFrame 对象的 to_csv() 方法也可以非常方便地将数据写入到 CSV 文件中。</p></li><li><p>读取</p><p> 我们同样可以使用 csv 库来读取 CSV 文件，例如我们现在将刚才写入的文件内容读取出来，代码如下：</p><pre><code> import csv with open(&#39;data.csv&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as csvfile: reader = csv.reader(csvfile)     for row in reader:         print(row)</code></pre><p> 运行结果：</p><pre><code> [&#39;id&#39;, &#39;name&#39;, &#39;age&#39;] [&#39;10001&#39;, &#39;Mike&#39;, &#39;20&#39;] [&#39;10002&#39;, &#39;Bob&#39;, &#39;22&#39;] [&#39;10003&#39;, &#39;Jordan&#39;, &#39;21&#39;] [&#39;10004&#39;, &#39;Durant&#39;, &#39;22&#39;] [&#39;10005&#39;, &#39;王伟&#39;, &#39;22&#39;]</code></pre><p> 在这里我们构造的是 Reader 对象，通过遍历输出了每行的内容，每一行都是一个列表形式，注意在这里如果 CSV 文件中包含中文的话需要指定文件编码。</p><p> 另外如果我们接触过 Pandas 的话，可以利用 read_csv() 方法将数据从 CSV 中读取出来，例如：</p><pre><code> import pandas  as pd df = pd.read_csv(&#39;data.csv&#39;) print(df)</code></pre><p> 运行结果：</p><pre><code>       id    name  age  10001    Mike   20  10002     Bob   22  10003  Jordan   21  10004  Durant   22  10005      王伟   22</code></pre></li></ol><p>参考链接  </p><ul><li><a href="https://www.cnblogs.com/sanduzxcvbnm/p/10334954.html" target="_blank" rel="noopener">爬虫文件存储:txt文档，json文件，csv文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫页面的数据提取</title>
      <link href="/2019/06/01/pa-chong/shu-ju-ti-qu/"/>
      <url>/2019/06/01/pa-chong/shu-ju-ti-qu/</url>
      
        <content type="html"><![CDATA[<h2 id="数据提取的几种方式"><a href="#数据提取的几种方式" class="headerlink" title="数据提取的几种方式"></a>数据提取的几种方式</h2><hr><h3 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h3><h4 id="1-语法规则"><a href="#1-语法规则" class="headerlink" title="1. 语法规则"></a>1. 语法规则</h4><ul><li><p>单个字符</p><p>  <code>.</code> 用来匹配除了换行符以外的任意<strong>单个</strong>字符 。</p><p>  <code>\d</code> 匹配单个数字</p><p>  <code>\w</code> 匹配单个字符 ，在ASCII码中等价于 <em>[a-zA-Z0-9</em>]_ ，在Unicode中则更加匹配内容更加广泛</p><p>  <code>\s</code> 匹配单个空白字符，包含space、tab以及换行符等</p><p>  <code>\b</code> 匹配单词边界</p><p>  <code>[abc]</code> 匹配范围内的单个字符串，这个例子可以匹配a、b或者c；这个例子也可以表示为<code>[a-c]</code></p><p>  <code>^</code> 匹配开头</p><p>  <code>$</code> 匹配结尾 ，<em>如果开始拥有权力，必然最后获得金钱</em>。</p></li><li><p>多个字符</p><p>  <code>?</code> 重复0次或者1次 ；</p><p>  <code>*</code> 重复0次以上 ； 重复0次，说明前面的字符可以不存在。</p><p>  <code>+</code> 重复1次以上 。</p><p>  <code>{n}</code> 重复n次；</p><p>  <code>{n,m}</code> 重复n到m次</p><p>  如果上限没有指定，也就是m置空，则表示字符串重复n次及以上。 注意上面的规则都是添加到前一个字符上的，如果是希望匹配重复的字符串，就是使用到<code>( )</code>符号，其后跟随数值限定表达式，例如<code>(test){1,3}</code>就可以匹配<code>test</code>、<code>testtest</code>以及<code>testtesttest</code> 字符串。</p><p>  <code>( )</code> 还有一个重要的作用来表示捕获组（capture group），对于捕获组的内容有两种引用方式，一个是在正则表达式外部引用，另一个就是在内部引用，后者也常被称为反向引用。</p></li><li><p>反向引用</p><p>  反向引用是用来<strong>识别重复模式</strong>的，例如经常说到ABAB模式，就是AB的重复。包含反向参考的正则表达式有如下特征：<code>(xxx)\number</code> ，其中的number用来指代正则表达式中第几个捕获组，捕获组序号从1开始。</p><p>  理论上太过于抽象， 通过例子看会更加清晰。 <code>(\w+)\s+\1</code> 这个表达式可以识别连续的重复单词，例如<code>go go</code>等，利用的就是反向引用，利用<code>\1</code>来表示表示<code>(\w+)</code>所匹配到的内容，同样多个分组也是可以匹配上的，<code>(\w+)\s+(\w+)\s+\1\s+\2</code> 可以识别出<code>go here go here</code>这样的模式。</p></li><li><p>标识符</p><p>  上述已经构成了一个正则表达式的基本规则，但是在实际使用中会添加几个标识符来实现更便捷的功能。在python中有以下几种方式。多个规则一起使用写做（re.I | re.M）</p><ul><li>re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）</li><li>re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）</li><li>re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为</li><li>re.L(全拼：LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定</li><li>re.U(全拼：UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性</li><li>re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</li></ul></li></ul><h4 id="2-Python中使用"><a href="#2-Python中使用" class="headerlink" title="2.Python中使用"></a>2.Python中使用</h4><p>Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下</p><pre><code>#返回pattern对象re.compile(string[,flag])  #以下为匹配所用函数re.match(pattern, string[, flags]) re.search(pattern, string[, flags])re.split(pattern, string[, maxsplit])re.findall(pattern, string[, flags])re.finditer(pattern, string[, flags])re.sub(pattern, repl, string[, count])re.subn(pattern, repl, string[, count])</code></pre><p>pattern可以理解为一个匹配模式，通常写做</p><pre><code>pattern = re.compile(r&#39;(?&lt;=&lt;td&gt;)\d+?(?=&lt;/td&gt;)&#39;, re.M)</code></pre><ul><li><code>match</code>从字符串开头匹配，匹配到返回match的对象，匹配不到返回None </li><li><code>search</code>扫描整个字符串返回第一个匹配到的元素并结束，匹配不到返回None</li><li><code>split</code>通过正则表达式将字符串分离。如果用括号将正则表达式括起来，那么匹配的字符串也会被列入到list中返回。maxsplit是分离的次数，maxsplit=1分离一次，默认为0，不限制次数。</li><li><code>findall</code>以列表的形式返回能匹配的子串</li><li><code>finditer</code>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。</li><li><code>sub</code> 使用repl替换string中每一个匹配的子串后返回替换后的字符串。 当repl是一个字符串时，可以使用\id或\g<id>、\g<name>引用分组，但不能使用编号0。 当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 count用于指定最多替换次数，不指定时全部替换。 </name></id></li><li><code>subn</code>函数返回元组</li></ul><p>简单案例</p><pre><code>import requestsimport reuser_agent =UserAgent()html = requests.get(&quot;https://www.xicidaili.com/nn/&quot;).textpattern = re.compile(r&#39;(?&lt;=&lt;td&gt;)\d*\.\d*\.\d*\.\d*(?=&lt;/td&gt;)&#39;) #获取ip地址iplist=re.findall(pattern,html)</code></pre><h4 id="3-其他应用"><a href="#3-其他应用" class="headerlink" title="3.其他应用"></a>3.其他应用</h4><p><a href="https://blog.csdn.net/bitcarmanlee/article/details/51106726" target="_blank" rel="noopener">hive 正则表达式详解</a> 在hive中涉及三个函数：<em>regexp</em>、_regexp_extract_ 以及 _regexp_replace_</p><p><a href="https://blog.csdn.net/andyzhaojianhui/article/details/46650255" target="_blank" rel="noopener">mysql中replace、regexp正则表达式替换用法</a> 利用replace 配合update子句来实现内容的更新</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/regexp.html" target="_blank" rel="noopener">12.5.2 Regular Expressions</a> 介绍了MySQL下的regexp的使用方法</p><h3 id="二、Xpath"><a href="#二、Xpath" class="headerlink" title="二、Xpath"></a>二、Xpath</h3><h4 id="1-Xpath语法"><a href="#1-Xpath语法" class="headerlink" title="1.Xpath语法"></a>1.Xpath语法</h4><ul><li>//book[1]/title   #第一个book节点下的标题</li><li>//book/price/text()   #节点下的文本</li><li>//bookstore/book[price&gt;35]/price  # 选取价格高于 35 的所有 price 节点</li><li>//bookstore/book[price&gt;35]/title  # 选取价格高于 35 的所有 title 节点</li><li>//div[@id=”ip_list”]/a/@href     #选取链接</li><li>//div[4]/img/@src  #取图片地址</li><li>//@code   #匹配所有带有code属性的属性值</li><li>//div/node() #获取注释</li></ul><h4 id="2-简单下载-amp-调用"><a href="#2-简单下载-amp-调用" class="headerlink" title="2.简单下载&amp;调用"></a>2.简单下载&amp;调用</h4><pre><code>### 下载 ###pip3 install lxml### 使用 ###from lxml import etreecontent = etree.HTML(html)content.xpath(&#39;//*[@id=&quot;ip_list&quot;]//tr/td[4]/a/text()&#39;)</code></pre><p>chrome有个工具叫xpath-helper,可以去应用商店下载，这样就可以用这个工具来检查你的xpath语法是否正确了。<br>另外如果语法正确，但是在程序中提取不到，查看源代码,因为在浏览器中普遍会对html代码进行优化，在源代码中定位到目标元素中后发现表格中的table元素下没有tbody，是浏览器自动加上去的，还有就是p元素的标签没有闭合，也是浏览器自动补上去的…之后就可以根据原始的html代码而进行查找了。如果还不可以，这时就要考虑原网页是动态页面，需要用到js解析了。</p><h3 id="二、BeautifulSoup"><a href="#二、BeautifulSoup" class="headerlink" title="二、BeautifulSoup"></a>二、BeautifulSoup</h3><p>一个灵活又方便的网页解析库，处理高效，支持多种解析器。</p><h4 id="1-解析器"><a href="#1-解析器" class="headerlink" title="1.解析器"></a>1.解析器</h4><p>Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快，推荐安装。</p><p><img src="/2019/06/01/pa-chong/shu-ju-ti-qu/jiexiqi.jpg" alt> </p><h4 id="2-Beautifulsoup语法"><a href="#2-Beautifulsoup语法" class="headerlink" title="2.Beautifulsoup语法"></a>2.Beautifulsoup语法</h4><ol><li><p>案例</p><pre><code> ### 导入 ### from bs4 import BeautifulSoup html = &#39;&#39;&#39; &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt; &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;, &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/aand &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt; &#39;&#39;&#39; ### 将网页解析为Beautifulsoup对象 ### soup = BeautifulSoup(html,&#39;lxml&#39;) #### 美化后打印 #### print(soup.prettify())  #### 打印出title标签 #### print(soup.title)                     #### 打印出title标签名字 #### print(soup.title.name) #### 打印出title标签内字符 #### print(soup.title.string) #### 打印出title标签的父标签名字 #### print(soup.title.parent.name) #### 打印出p标签 #### print(soup.p) #### 打印出p标签class名字 #### print(soup.p[&quot;class&quot;]) #### 打印a便签 #### print(soup.a) ### 打印全部a便签，结果为list ### print(soup.find_all(&#39;a&#39;)) #### 打印id=link3的标签 #### print(soup.find(id=&#39;link3&#39;))</code></pre><hr><pre><code> ### 输出结果 ### &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt; title The Dormouse&#39;s story head &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt; [&#39;title&#39;] &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt; [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;] &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</code></pre><hr><pre><code> for link in soup.find_all(&#39;a&#39;):     ### 获取a标签的链接 ###     print(link.get(&#39;href&#39;)) ### 获取所有内容 ### print(soup.get_text())</code></pre></li><li><p>基本使用</p><ul><li><code>soup.标签名</code> 我们就可以获得这个标签的内容 返回的结果是第一个标签的内容</li><li><code>soup.title.name</code>的时候就可以获得该title标签的名称</li><li><code>soup.p[&#39;name&#39;]</code>  <code>soup.p.attrs[&#39;name&#39;]</code> 可以获取p标签的name属性值</li><li><code>soup.p.string</code> 可以获取第一个p标签的内容</li><li><code>soup.head.title.string</code>  嵌套选择</li><li><code>soup.p.contents</code> 将p标签下的所有子标签存入到了一个列表中</li><li><code>soup.p.children</code> 获取p标签下的所有子节点内容和通过contents获取的结果是一样的，但是不同的地方是soup.p.children是一个迭代对象，而不是列表，只能通过循环的方式获取素有的信息</li><li><code>soup.descendants</code> contents以及children都是获取子节点，如果想要获取子孙节点可以通过descendants，这种获取的结果也是一个迭代器</li><li><code>soup.a.parent</code>就可以获取父节点的信息</li><li><blockquote><p><code>soup.a.next_siblings</code> 获取后面的兄弟节点<br><code>soup.a.previous_siblings</code> 获取前面的兄弟节点<br><code>soup.a.next_sibling</code> 获取下一个兄弟标签<br><code>souo.a.previous_sinbling</code> 获取上一个兄弟标签  </p></blockquote></li></ul></li><li><p>标准选择</p><ul><li><p>find_all(name,attrs,recursive,text,**kwargs) 根据标签名，属性，内容查找文档</p><ul><li><strong>name</strong>    <code>soup.find_all(&#39;ul&#39;)</code></li><li><strong>attrs</strong>   <code>soup.find_all(attrs={&#39;name&#39;: &#39;elements&#39;})</code>  # attrs可以传入字典的方式来查找标签，但是这里有个特殊的就是class,因为class在python中是特殊的字段，所以如果想要查找class相关的可以更改attrs={‘class_’:’element’}或者soup.find_all(‘’,{“class”:”element})，特殊的标签属性可以不写attrs，例如id</li><li><strong>text</strong> soup.find_all(text=’Foo’)  # 结果返回的是查到的所有的text=’Foo’的文本</li></ul></li><li><p>find(name,attrs,recursive,text,**kwargs)  返回的匹配结果的第一个元素</p><ul><li>find_parents() 返回所有祖先节点</li><li>find_parent() 返回直接父节点。</li><li>find_next_siblings() 返回后面所有兄弟节点</li><li>find_next_sibling() 返回后面第一个兄弟节点</li><li>find_previous_siblings() 返回前面所有兄弟节点</li><li>find_previous_sibling() 返回前面第一个兄弟节点</li><li>find_all_next() 返回节点后所有符合条件的节点</li><li>find_next() 返回第一个符合条件的节点</li><li>find_all_previous() 返回节点后所有符合条件的节点</li><li>find_previous() 返回第一个符合条件的节点</li></ul></li></ul></li><li><p>CSS选择器</p><ul><li><p>通过<code>select()</code>直接传入CSS选择器就可以完成选择，熟悉前端的人对CSS可能更加了解，其实用法也是一样的 <code>.</code> 表示class；  <code>#</code> 表示id</p><ul><li>soup.select(‘.panel .panel-heading’)</li><li>soup.select(‘ul li’)</li><li>soup.select(‘#list-2 .element’)</li></ul></li><li><p><code>get_text()</code> 获取文本内容</p><ul><li>soup.select(‘li’)[1].get_text()</li></ul></li><li><p><code>[属性名]或者attrs[属性名]</code> 获取属性</p><ul><li><code>ul[&#39;id&#39;]</code></li><li><code>ul.attrs[&#39;id&#39;]</code></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫请求页面的几种方法</title>
      <link href="/2019/05/28/pa-chong/qing-qiu-ye-mian/"/>
      <url>/2019/05/28/pa-chong/qing-qiu-ye-mian/</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫请求页面的几种方法"><a href="#爬虫请求页面的几种方法" class="headerlink" title="爬虫请求页面的几种方法"></a>爬虫请求页面的几种方法</h2><p>看了好多爬虫请求方式，大同小异。在这里汇总整理一下几种请求网页的方式。文内含构造请求头，设置代理。</p><p>python中有多种库可以用来处理http请求，比如python的原生库：urllib包、requests类库。urllib和urllib2是相互独立的模块，python3.0以上把urllib和urllib2合并成一个库了，requests库使用了urllib3。requests库的口号是“HTTP For Humans”，为人类使用HTTP而生，用起来不知道要比python原生库好用多少呢，比起urllib包的繁琐，requests库特别简洁和容易理解。</p><p>其中比较常用的方法是 requests、selenium</p><p>pyppeteer 一些逆向化比较好</p><h3 id="一、urllib-request"><a href="#一、urllib-request" class="headerlink" title="一、urllib.request"></a>一、urllib.request</h3><ol><li><p>urllib包中的urllib.request 经常配合 urllib.parse 来一起使用，里面的 urlencode 可以把key-value这样的键值对转换成我们想要的格式</p><pre><code> dic = {     &quot;jl&quot;:city,     &quot;kw&quot;:profession,     &quot;p&quot;:page } urlwith = urllib.parse.urlencode(dic1) urlFinal = url + urlwith</code></pre></li><li><p>请求网页代码</p><pre><code> from fake_useragent import UserAgent  #随机情求头 import urllib.request user_agent =UserAgent() request = urllib.request.Request(&quot;https://httpbin.org/ip&quot;) request.add_header(&quot;User-Agent&quot;, user_agent.random) response = urllib.request.urlopen(request) html = response.read().decode(&quot;utf8&quot;,&#39;ignore&#39;) print(html)</code></pre></li></ol><h3 id="二、requests"><a href="#二、requests" class="headerlink" title="二、requests"></a>二、requests</h3><ol><li><p>安装</p><blockquote><p>pip install requests</p></blockquote></li><li><p>请求网页代码</p></li></ol><pre><code>from fake_useragent import UserAgent  #随机情求头import requestsuser_agent =UserAgent()headers = {            &#39;Cookie&#39;:&#39;&#39; ,            &#39;User-Agent&#39;: user_agent.random            }proxy ={        &#39;https&#39;:&#39;218.241.219.226:9999&#39;        }html = requests.get(&quot;https://www.xicidaili.com/&quot;, headers=headers, proxies=proxy)print(html.text)</code></pre><h3 id="三、selenium"><a href="#三、selenium" class="headerlink" title="三、selenium"></a>三、selenium</h3><p>1.请求网页代码</p><pre><code>from selenium import webdriverchromeOptions = webdriver.ChromeOptions()browser = webdriver.Chrome()#设置代理ip# chromeOptions.add_argument(&quot;--proxy-server=https://112.85.130.91:9999&quot;)# 一定要注意，=两边不能有空格，不能是这样--proxy-server = http://202.20.16.82:10152# browser = webdriver.Chrome(options = chromeOptions)browser.get(&quot;https://httpbin.org/ip&quot;)# cookies = driver.get_cookies()print(browser.page_source)#打印cookiesprint(browser.get_cookies())</code></pre><h3 id="四、pyppeteer"><a href="#四、pyppeteer" class="headerlink" title="四、pyppeteer"></a>四、pyppeteer</h3><p>1.请求网页代码</p><pre><code>import pyppeteer#浏览器地址exepath = &#39;C:/Users/Administrator/AppData/Local/Google/Chrome/Application/chrome.exe&#39;browser = await launch({&#39;executablePath&#39;: exepath, &#39;headless&#39;: True, &#39;slowMo&#39;: 30})page = await browser.newPage()await page.setViewport({&#39;width&#39;: 1366, &#39;height&#39;: 768})await page.goto(&#39;https://httpbin.org/ip&#39;)print(await page.content())#打印cookiesprint(await page.cookies())</code></pre><h3 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h3><ol><li>从网页中提取数据</li><li>re</li><li>xpath</li><li>beautifulsoup</li><li>selenium</li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三大分析法-SWOT、PEST、波特五力</title>
      <link href="/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/"/>
      <url>/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="三大分析法—SWOT、PEST、波特五力"><a href="#三大分析法—SWOT、PEST、波特五力" class="headerlink" title="三大分析法—SWOT、PEST、波特五力"></a>三大分析法—SWOT、PEST、波特五力</h2><blockquote><p>大部分行业中的企业，相互之间的利益都是紧密联系在一起的，作为企业整体战略一部分的各企业竞争战略，其目标都在于使得自己的企业获得相对于竞争对手的优势，所以，在实施中就必然会产生冲突与对抗现象，这些冲突与对抗就构成了现有企业之间的竞争。现有企业之间的竞争常常表现在价格、广告、产品介绍、售后服务等方面，其竞争强度与许多因素有关。</p></blockquote><h3 id="SWOT分析法"><a href="#SWOT分析法" class="headerlink" title="SWOT分析法"></a>SWOT分析法</h3><p>「SWOT分析模型简介」</p><p>（也称TOWS分析法、道斯矩阵）。在现在的战略规划报告里，SWOT分析应该算是一个众所周知的工具。来自于麦肯锡咨询公司的SWOT分析，包括分析企业的优势（Strengths）、劣势（Weaknesses）、机会（Opportunities）和威胁（Threats）。因此，SWOT分析实际上是将对企业内外部条件各方面内容进行综合和概括，进而分析组织的优劣势、面临的机会和威胁的一种方法。</p><p>通过SWOT分析，可以帮助企业把资源和行动聚集在自己的强项和有最多机会的地方；并让企业的战略变得明朗。</p><p><img src="/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/1.png" alt></p><p><strong>「SWOT模型含义介绍」</strong></p><p>优劣势分析主要是着眼于企业自身的实力及其与竞争对手的比较，而机会和威胁分析将注意力放在外部环境的变化及对企业的可能影响上。在分析时，应把所有的内部因素（即优劣势）集中在一起，然后用外部的力量来对这些因素进行评估。</p><p>1.机会与威胁分析（environmental opportunities and threats）</p><p>环境发展趋势分为两大类：一类表示环境威胁，另一类表示环境机会。环境威胁指的是环境中一种不利的发展趋势所形成的挑战，如果不采取果断的战略行为，这种不利趋势将导致公司的竞争地位受到削弱。环境机会就是对公司行为富有吸引力的领域，在这一领域中，该公司将拥有竞争优势。</p><p>对环境的分析也可以有不同的角度。比如，一种简明扼要的方法就是PEST分析，另外一种比较常见的方法就是波特的五力分析。</p><p>2、 优势与劣势分析（Strengths and weaknesses）</p><p>由于企业是一个整体，而且竞争性优势来源十分广泛，所以，在做优劣势分析时必须从整个价值链的每个环节上，将企业与竞争对手做详细的对比。如产品是否新颖，制造工艺是否复杂，销售渠道是否畅通，以及价格是否具有竞争性等。如果一个企业在某一方面或几个方面的优势正是该行业企业应具备的关键成功要素，那么，该企业的综合竞争优势也许就强一些。需要指出的是，衡量一个企业及其产品是否具有竞争优势，只能站在现有潜在用户角度上，而不是站在企业的角度上。</p><p>企业在维持竞争优势过程中，必须深刻认识自身的资源和能力，采取适当的措施。因为一个企业一旦在某一方面具有了竞争优势，势必会吸引到竞争对手的注意。一般地说，企业经过一段时期的努力，建立起某种竞争优势;然后就处于维持这种竞争优势的态势，竞争对手开始逐渐做出反应;而后，如果竞争对手直接进攻企业的优势所在，或采取其它更为有力的策略，就会使这种优势受到削弱。</p><p>而影响企业竞争优势的持续时间，主要的是三个关键因素：</p><p>1. 建立这种优势要多长时间?</p><p>2. 能够获得的优势有多大？</p><p>3. 竞争对手做出有力反应需要多长时间？</p><p><strong>「SWOT分析步骤」</strong></p><p>1、 确认当前的战略是什么？</p><p>2、 确认企业外部环境的变化（波特五力或者PEST）</p><p>3、 根据企业资源组合情况，确认企业的关键能力和关键限制。</p><p>4、 按照通用矩阵或类似的方式打分评价</p><p>把识别出的所有优势分成两组，分的时候以两个原则为基础：它们是与行业中潜在的机会有关，还是与潜在的威胁有关。用同样的办法把所有的劣势分成两组，一组与机会有关，另一组与威胁有关。</p><p>5、将结果在SWOT分析图上定位</p><p><img src="/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/2.gif" alt></p><p>或者用SWOT分析表，将刚才的优势和劣势按机会和威胁分别填入表格。</p><p><img src="/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/3.jpg" alt></p><p>6、 战略分析</p><p>成功应用SWOT分析法的简单规则：</p><p>进行SWOT分析的时候必须对公司的优势与劣势有客观的认识；</p><p>进行SWOT分析的时候必须区分公司的现状与前景；</p><p>进行SWOT分析的时候必须考虑全面。</p><p>进行SWOT分析的时候必须与竞争对手进行比较，比如优于或是劣于你的竞争对手；</p><p>保持SWOT分析法的简洁化，避免复杂化与过度分析；</p><p>SWOT分析法因人而异。</p><p>一旦使用SWOT分析法决定了关键问题，也就确定是市场营销的目标。SWOT分析法可与PEST analysis和Porter’s Five-Forces analysis等工具一起使用。运用SWOT分析法的时候，要将不用的要素列入相关的表格当中去，很容易操作。</p><p>针对SWOT中的机会部分，可以用PEST进行分析得到系统的结果。</p><p>针对SWOT中的威胁部分，可以用五力分析模型来得到系统的分析结果。</p><h3 id="PEST分析法"><a href="#PEST分析法" class="headerlink" title="PEST分析法"></a>PEST分析法</h3><p>PEST是从政治（Politics）、经济（Economic）、社会（Society）、技术（Technology）四个方面，基于公司战略的眼光来分析企业外部宏观环境的一种方法。公司战略的制定离不开宏观环境，而PEST分析法能从各个方面比较好的把握宏观环境的现状及变化的趋势，有利于企业对生存发展的机会加以利用，对环境可能带来的威胁及早发现避开。</p><p><img src="/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/4.png" alt></p><p>要想提高商品的销量，少不了要做产品分析，只有了解了用户的需求，知道用户要什么，才能根据这些数据更好的进行产品优化和活动推广。说到分析方法，可能有些人第一个想到的就是SWOT，这种分析方法主要是能帮助企业找出自身优势，整合资源，从而形成企业的战略规划，如果想要更加深入了解产品分析的话，最好还是用PEST分析法。</p><p><strong>PEST分析的内容</strong></p><p>一、政治环境，是指一个国家或地区的政治制度、体制、方针政策、法律法规等方面。这些因素常常影响着企业的经营行为，尤其是对企业长期的投资行为有着较大影响。</p><p>二、经济环境，指企业在制定战略过程中须考虑的国内外经济条件、宏观经济政策、经济发展水平等多种因素</p><p>三、社会环境，主要指组织所在社会中成员的民族特征、文化传统、价值观念、宗教信仰、教育水平以及风俗习惯等因素。</p><p>四、 技术环境，是指企业业务所涉及国家和地区的技术水平、技术政策、新产品开发能力以及技术发展的动态等。</p><p><img src="/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/5.png" alt></p><h3 id="波特五力模型"><a href="#波特五力模型" class="headerlink" title="波特五力模型"></a>波特五力模型</h3><p>五力分析模型是迈克尔·波特(Michael Porter)于80年代初提出，对企业战略制定产生全球性的深远影响。用于竞争战略的分析，可以有效的分析客户的竞争环境。五力分别是： 供应商的议价能力、购买者的议价能力、潜在竞争者进入的能力、替代品的替代能力、行业内竞争者现在的竞争能力。五种力量的不同组合变化最终影响行业利润潜力变化。</p><p><img src="/2019/05/25/luo-ji-si-wei/san-da-fen-xi-fa/6.png" alt></p><p>五力模型</p><p>供应商的议价能力</p><p>供方主要通过其提高投入要素价格与降低单位价值质量的能力，来影响行业中现有企业的盈利能力与产品竞争力。</p><p>购买者的议价能力</p><p>购买者主要通过其压价与要求提供较高的产品或服务质量的能力，来影响行业中现有企业的盈利能力。</p><p>新进入者的威胁</p><p>新进入者在给行业带来新生产能力、新资源的同时，将希望在已被现有企业瓜分完毕的市场中赢得一席之地，这就有可能会与现有企业发生原材料与市场份额的竞争，最终导致行业中现有企业盈利水平降低，严重的话还有可能危及这些企业的生存。竞争性进入威胁的严重程度取决于两方面的因素，这就是进入新领域的障碍大小与预期现有企业对于进入者的反应情况。</p><p>替代品的威胁</p><p>两个处于同行业或不同行业中的企业，可能会由于所生产的产品是互为替代品，从而在它们之间产生相互竞争行为，这种源自于替代品的竞争会以各种形式影响行业中现有企业的竞争战略。</p><p>同业竞争者的竞争程度</p><p>大部分行业中的企业，相互之间的利益都是紧密联系在一起的，作为企业整体战略一部分的各企业竞争战略，其目标都在于使得自己的企业获得相对于竞争对手的优势，所以，在实施中就必然会产生冲突与对抗现象，这些冲突与对抗就构成了现有企业之间的竞争。现有企业之间的竞争常常表现在价格、广告、产品介绍、售后服务等方面，其竞争强度与许多因素有关。</p><p>局限性</p><p>五力模型的前提假设是</p><p>1.能够清晰的界定行业边界，行业的规模是固定的。</p><p>但现实中企业之间往往不是通过吃掉对手而是与对手共同做大行业的蛋糕来获取更大的资源和市场。同时，市场可以通过不断的开发和创新来增大容量。</p><p>2.同行业之间只有竞争关系，没有合作关系。</p><p>但现实中企业之间存在多种合作关系，不一定是你死我活的竞争关系。</p><p>3.能搜集到一切有效信息（信息透明），制定战略者需要了解整个行业的信息。</p><p><strong>来源：知乎</strong></p>]]></content>
      
      
      <categories>
          
          <category> 逻辑思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析-关联规则（购物篮分析）</title>
      <link href="/2019/05/22/shu-ju-fen-xi/guan-lian-gui-ze/"/>
      <url>/2019/05/22/shu-ju-fen-xi/guan-lian-gui-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="关联规则算法"><a href="#关联规则算法" class="headerlink" title="关联规则算法"></a>关联规则算法</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h5 id="1-关联规则的一般形式"><a href="#1-关联规则的一般形式" class="headerlink" title="1. 关联规则的一般形式"></a>1. 关联规则的一般形式</h5><p>项集A、B同时发生的概率称为关联规则的支持度（也称相对支持度）：<br>Support（A→B）= P(A∩B)<br>项集A发生，则项集B发生的概率为关联规则的置信度：<br>Confidence（A→B）= P(B|A）  </p><h5 id="2-最小支持度和最小置信度"><a href="#2-最小支持度和最小置信度" class="headerlink" title="2. 最小支持度和最小置信度"></a>2. 最小支持度和最小置信度</h5><p>最小支持度是用户或专家定义的衡量支持度的一个阈值，表示项目集在统计意义上的最低重要性；最小置信度是用户或专家定义的衡量置信度的一个國值，表示关联规则的最低可靠性。同时满足最小支持度國值和最小置信度國值的规则称作强规则。</p><h5 id="3-项集"><a href="#3-项集" class="headerlink" title="3. 项集"></a>3. 项集</h5><p>项集是项的集合。包含个项的项集称为左项集，如集合{牛奶，麦片，糖}是一个3项集。<br>项集的出现频率是所有包含项集的事务计数，又称作绝对支持度或支持度计数。如果项集 I 的相对支持度满足预定义的最小支持度阈值，则 I 是频繁项集。  </p><h5 id="4-支持度计数"><a href="#4-支持度计数" class="headerlink" title="4. 支持度计数"></a>4. 支持度计数</h5><p>项集A的支持度计数是事务数据集中包含项集」的事务个数，简称为项集的频率或计数。<br>已知项集的支持度计数，则规则A→B的支持度和置信度很容易从所有事务计数、项集A和项集A∩B的支持度计数推出：<br>Support（A→B）= A、B同时发生的事务个数 / 所有事务个数 = Support_count(A∩B) / Total_count(A)Totalcount(A)</p><p>Confidence(A→B）= P(A|B) = Support（A∩B) / Support（A) = Support_count(A∩B) / Support_count(A)</p><p>也就是说，一旦得到所有事务个数，A，B和A∩B的支持度计数，就可以导出对应的关联规则 A→B 和 B→A，并可以检查该规则是否是强规则。</p><ul><li>支持度 Support  支持度是指在所有项集中{X, Y}出现的可能性，即项集中同时含有X和Y的概率. </li><li>置信度 Confidence   置信度表示在先决条件X发生的条件下，关联结果Y发生的概率(衡量了所考察的关联规则在“质”上的可靠性)</li><li><p>提升度 Lift   表示“使用X的用户中同时使用Y的比例”与“使用Y的用户比例”的比值    </p><pre><code>  Lift(X-&gt;Y) =Support(X,Y) / Support(X) / Support(Y)    ...... =frac{Confidence(X,Y)}{Support(Y)}    该指标与置信度同样衡量规则的可靠性，可以看作是置信度的一种互补指标</code></pre></li><li><p>出错率 Conviction  Conviction的意义在于度量规则预测错误的概率,表示X出现而Y不出现的概率  </p><pre><code>  Conviction(X-&gt;Y)=(1-Support(Y)) / (1-Confidence(X-&gt;Y))  </code></pre></li></ul><h3 id="规则生成基本流程"><a href="#规则生成基本流程" class="headerlink" title="规则生成基本流程"></a>规则生成基本流程</h3><p>一共有2步:</p><h5 id="1-找出频繁项集"><a href="#1-找出频繁项集" class="headerlink" title="1. 找出频繁项集"></a>1. 找出频繁项集</h5><p>找出所有的频繁项集（支持度必须大于等于给定的最小支持度阈值），在这个过程中连接步和剪枝步互相融合，最终得到最大频繁项集。  </p><ul><li>扫描数据项，对每个候选项计数，生成候选1-项集C1</li><li>定义最小支持度阈值为2，从C1生成频繁1-项集L1</li><li>通过L1xL1生成候选2-项集C2</li><li>扫描D，对C2里每个项计数，生成频繁2-项集L2</li><li>计算L3xL3，利用apriori性质：频繁项集的子集必然是频繁的，我们可以删去一部分项，从而得到C3，由C3再经过支持度计数生成L3</li><li>可见Apriori算法可以分成 <strong>连接，剪枝</strong> 两个步骤不断循环重复</li></ul><h5 id="2-由频繁项集生成关联规则"><a href="#2-由频繁项集生成关联规则" class="headerlink" title="2. 由频繁项集生成关联规则."></a>2. 由频繁项集生成关联规则.</h5><p>n个item,总共可以产生3^n - 2^(n+1) + 1条规则,指定最小置信度来过滤掉弱规则<br>置信度计算<br>Confidence(A→B）= P(A|B) = Support（A∩B) / Support（A) = Support_count(A∩B) / Support_count(A)</p><p>将这些候选规则与最小置信度阙值相比较,不能满足最小置信度的规则将被消除。</p><h3 id="R语言实现"><a href="#R语言实现" class="headerlink" title="R语言实现"></a>R语言实现</h3><p>数据读取</p><pre><code>setwd(&#39;xx/xx/arules&#39;)library(arules)library(data.table)# --- way1gou1 &lt;- read.transactions(&quot;./groceries.csv&quot;, format=&quot;basket&quot;, sep=&quot;,&quot;,skip=0)# as(data.table,&#39;transactions&#39;) 函数转化 # 参数说明：# format=c(&quot;basket&quot;, &quot;single&quot;)用于注明源数据的格式。如果源数据每行内容就是一条交易购买的商品列表（类似于一行就是一个购物篮）那么使用basket；如果每行内容是交易号+单个商品，那么使用single。# cols=c(&quot;transId&quot;, &quot;ItemId&quot;) 对于single格式，需要指定cols，二元向量（数字或字符串）。如果是字符串，那么文件的第一行是表头（即列名）。第一个元素是交易号的字段名，第二个元素是商品编号的字段名。如果是数字，那么无需表头。对于basket，一般设置为NULL，缺省也是NULL，所以不用指定。# signle format的数据格式如下所示，与此同时，需要设定cols=c(1, 2)# 1001,Fries# 1001,Coffee# 1001,Milk# 1002,Coffee# 1002,Fries# rm.duplicates=FALSE：表示对于同一交易，是否需要删除重复的商品</code></pre><p>筛选购买两件商品以上的交易  </p><pre><code>groceries_use &lt;- groceries[basketSize &gt; 1]  dim(groceries)[1] 9835  169  dim(groceries_use)  [1] 7676  169</code></pre><p>每个购物list里包含商品的数量 </p><pre><code># 每个购物list里包含商品的数量 length in each basket(row) &gt; basketSize&lt;-size(groceries)&gt; table(basketSize)basketSize   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 2159 1643 1299 1005  855  645  545  438  350  246  182  117   78   77   55   46   17   18   19   20   21   22   23   24   26   27   28   29   32   29   14   14    9   11    4    6    1    1    1    1    3    1 # 单个商品的出现频率 Support of each item &gt; itemFreq &lt;- itemFrequency(groceries)  &gt; (head(itemFreq[order(-itemFreq)]))      whole milk other vegetables       rolls/buns             soda        0.2555160        0.1934926        0.1839349        0.1743772           yogurt    bottled water        0.1395018        0.1105236</code></pre><p>按最小支持度查看</p><pre><code># itemfreq &gt;= 0.1itemFrequencyPlot(groceries, support= quantile(itemFreq,0.9))  </code></pre><p>按topn支持度查看</p><pre><code># head(itemFreq[order(-itemFreq)],10)itemFrequencyPlot(groceries, topN=10, horiz=T) </code></pre><hr><pre><code>library(arules) #加载arules程序包data(Groceries) #调用数据文件Inspect(Groceries) #观看数据集里的数据#求频繁项集frequentsets=eclat(Groceries,parameter=list(support=0.05,maxlen=10))inspect(frequentsets[1:10])inspect(sort(frequentsets,by=&quot;support&quot;)[1:10]) #根据支持度对求得的频繁项集排序并察看#利用apriori函数提取关联规则rules&lt;-apriori(Groceries,parameter=list(support=0.01,confidence=0.5))#规则查看Inspect(rules)#Actionable 这些rule提供了非常清晰、有用的洞察，可以直接应用在业务上</code></pre><h5 id="1-如何发现有用的rule"><a href="#1-如何发现有用的rule" class="headerlink" title="1. 如何发现有用的rule"></a>1. 如何发现有用的rule</h5><ol><li><p>按照 lift 对规则进行排序  </p><pre><code> ordered_groceryrules &lt;- sort(rules, by=&quot;lift&quot;) inspect(ordered_groceryrules[1:5])</code></pre><p> 其中 lift 是一个类似相关系数的指标。lift=1时表示L和R独立。这个数越大，越表明L和R存在在一个购物篮中不是偶然现象。</p></li><li><p>规则搜索</p><pre><code> yogurtrules &lt;- subset(rules, items %in% c(&quot;yogurt&quot;))  inspect(yogurtrules[1:3])</code></pre><p> items %in% c(“A”, “B”)表示 lhs+rhs的项集的并集中，至少有一个item是在c(“A”, “B”)  item = A or item = B<br> 如果仅仅想搜索lhs或者rhs，那么用lhs或rhs替换items即可。如：lhs %in% c(“yogurt”)<br> %in%是精确匹配<br> %pin%是部分匹配，也就是说只要item like ‘%A%’ or item like ‘%B%’<br> %ain%是完全匹配，也就是说itemset has ’A’ and itemset has ‘B’  </p></li><li><p>通过 条件运算符(&amp;, |, !) 添加 support, confidence, lift的过滤条件</p><pre><code> fruitrules &lt;- subset(rules, items %pin% c(&quot;fruit&quot;))      byrules &lt;- subset(rules, items %ain% c(&quot;berries&quot;)) fruitrules &lt;- subset(rules, items %pin% c(&quot;fruit&quot;) &amp; lift &gt; 2) x=subset(rules,subset=rhs%in%&quot;whole milk&quot;&amp;lift&gt;=1.2) </code></pre></li><li><p>获取出support,confidence,lift外的其他评价标准</p><pre><code> qualityMeasures &lt;- interestMeasure(groceryrules,                             measure = c(&quot;coverage&quot;,&quot;fishersExactTest&quot;,                                     &quot;conviction&quot;, &quot;chiSquared&quot;),                             transactions=groceries_use) summary(qualityMeasures)     coverage        fishersExactTest      conviction       chiSquared        Min.   :0.009964   Min.   :0.0000000   Min.   :0.9977   Min.   :  0.0106    1st Qu.:0.018709   1st Qu.:0.0000000   1st Qu.:1.1914   1st Qu.: 25.0673    Median :0.024809   Median :0.0000000   Median :1.2695   Median : 45.6076    Mean   :0.032608   Mean   :0.0068474   Mean   :1.3245   Mean   : 54.9651    3rd Qu.:0.035892   3rd Qu.:0.0000026   3rd Qu.:1.4091   3rd Qu.: 75.8146    Max.   :0.255516   Max.   :0.5881507   Max.   :2.1897   Max.   :350.0989 </code></pre><ul><li>第三个参数transactions：一般情况下都是原来那个数据集，但也有可能是其它数据集，用于检验这些rules在其他数据集上的效果。所以，这也是评估rules的一种方法：在其它数据集上计算这些规则的quality measure用以评估效果。  </li><li>fishersExactTest 的p值大部分都是 &gt;= 0.05, 这就说明这些规则反应出了真实的用户的行为模式。</li><li>coverage从0.01 ~ 0.30，相当于覆盖到了多少范围的用户。  </li><li>ChiSquared: 考察该规则的LHS和RHS是否独立？即LHS与RHS的列联表的ChiSquare Test。p&lt;0.05表示独立，否则表示不独立。  </li></ul></li><li><p>限制挖掘的item  </p><p> 可以控制规则的左手边或者右手边出现的item，即appearance。但尽量要放低支持度和置信度  </p><pre><code> berriesInLHS &lt;- apriori(groceries,                          parameter = list( support = 0.003,                                            confidence = 0.1,                                           minlen=2),                          appearance = list(lhs = c(&quot;berries&quot;),                                            default=&quot;rhs&quot;)) # 既然lhs都是&quot;berries&quot;，那么只查看rhs的itemset即可 &gt; inspect(rhs(berriesInLHS[1:5])) # 使用subset进行进一步过滤. 如,不希望看到rhs包含&quot;root vegetables&quot; 或 &quot;whole milk&quot; &gt; berrySub &lt;- subset(berriesInLHS, subset = !(rhs %in% c(&quot;root vegetables&quot;, &quot;whole milk&quot;))) &gt; inspect(sort(berrySub, by=&quot;confidence&quot;)[1:5])</code></pre></li></ol><h5 id="2-其他操作"><a href="#2-其他操作" class="headerlink" title="2. 其他操作"></a>2. 其他操作</h5><ol><li><p>保存挖掘的结果</p><pre><code> #保存到文件。可以与外部程序进行交换。 write(rules, file=&quot;./groceryrules.csv&quot;, sep=&quot;,&quot;, quote=TRUE, row.names=FALSE)   #转换为data.frame &gt; groceryrules_df &lt;- as(rules, &quot;data.frame&quot;)   &gt; str(groceryrules_df)  </code></pre></li><li><p>图形展示</p><ul><li><p>Scatter Plot </p><pre><code> library(arulesViz) library(RColorBrewer) plot(groceryrules,      control=list(jitter=2,col=rev(brewer.pal(9, &quot;Greens&quot;)[4:9])),      shading = &#39;lift&#39;)</code></pre><p> <img src="/2019/05/22/shu-ju-fen-xi/guan-lian-gui-ze/Scatter Plot.png" alt> </p><p> shading = “lift”： 表示在散点图上颜色深浅的度量是lift。当然也可以设置为support 或者Confidence<br> jitter=2：增加抖动值<br> col: 调色板，默认是100个颜色的灰色调色板<br> brewer.pal(n, name): 创建调色板：n表示该调色板内总共有多少种颜色；name表示调色板的名字(参考help)<br> 这里使用Green这块调色板，引入9中颜色<br> 这幅散点图表示了规则的分布图：大部分规则的support在0.1以内，Confidence在0-0.8内。每个点的颜色深浅代表了lift的值   </p></li></ul></li></ol><ul><li><p>Grouped Matrix</p><pre><code>  plot(groceryrules,method=&#39;grouped&#39;,   control = list(col=rev(brewer.pal(9, &quot;Greens&quot;)[4:9])))</code></pre></li></ul><p><img src="/2019/05/22/shu-ju-fen-xi/guan-lian-gui-ze/Grouped Matrix.png" alt> </p><ul><li><p>Graph</p><pre><code>  top.vegie.rules &lt;- sort(groceryrules,by=c(&#39;support&#39;,&#39;lift&#39;))[1:10]  plot(top.vegie.rules, measure=&quot;support&quot;, method=&quot;graph&quot;, shading = &quot;lift&quot;)</code></pre></li></ul><p><img src="/2019/05/22/shu-ju-fen-xi/guan-lian-gui-ze/Graph.png" alt></p><h5 id="5-致谢"><a href="#5-致谢" class="headerlink" title="5. 致谢"></a>5. 致谢</h5><ul><li><a href="http://blog.csdn.net/gjwang1983/article/details/45015203" target="_blank" rel="noopener">R语言 | 关联规则</a></li><li><a href="https://www.jianshu.com/p/1e9ce1b24626" target="_blank" rel="noopener">购物篮分析-Apriori算法</a></li><li><a href="http://www.idatacamp.com/405.html/" target="_blank" rel="noopener">用R语言进行购物篮分析</a></li><li><a href="https://yq.aliyun.com/articles/89742" target="_blank" rel="noopener">R语言数据挖掘-2.2购物篮分析</a></li><li><a href="https://zhuanlan.zhihu.com/lhf-data/20537735" target="_blank" rel="noopener">购物篮关联分析-R挖掘Apriori算法</a></li><li><a href="https://www.douban.com/note/334094701/" target="_blank" rel="noopener">R语言学习之关联规则算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-电影评分预测模型</title>
      <link href="/2019/05/19/shu-ju-fen-xi/r-yu-yan-dian-ying-ping-fen-yu-ce-mo-xing/"/>
      <url>/2019/05/19/shu-ju-fen-xi/r-yu-yan-dian-ying-ping-fen-yu-ce-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="R语言-电影评分预测模型"><a href="#R语言-电影评分预测模型" class="headerlink" title="R语言-电影评分预测模型"></a>R语言-电影评分预测模型</h2><p>评分系统是一种常见的推荐系统。</p><p>现在使用R语言基于协同过滤算法来构建一个电影评分预测模型及电影推荐模型。</p><h3 id="一、前提准备"><a href="#一、前提准备" class="headerlink" title="一、前提准备"></a>一、前提准备</h3><ol><li><p>R语言包：  </p><ul><li>ggplot2包（绘图），    </li><li>recommenderlab包，    </li><li>reshape包（数据处理）  <pre><code>   install.packages(&quot;recommenderlab&quot;)   install.packages(&quot;reshape&quot;)   install.packages(&quot;ggplot2&quot;)   library(recommenderlab)   library(reshape)   library(ggplot2) </code></pre></li></ul></li><li><p>获取数据：大家可以在明尼苏达州大学的社会化计算研究中心官网上面下载这些免费数据集，网站链接为<a href="http://grouplens.org/datasets/movielens/" target="_blank" rel="noopener">http://grouplens.org/datasets/movielens/</a></p><p> 或者：链接：<a href="https://pan.baidu.com/s/1o8mlt8Y" target="_blank" rel="noopener">https://pan.baidu.com/s/1o8mlt8Y</a> 密码：bkyu</p><p> 数据说明：</p><p> 这个数据集包括：     </p><ul><li>来自943个用户的1682个电影的10万个评级（1-5）。 </li><li>每个用户已经评价至少20部电影。 </li><li>为用户提供简单的人口统计信息（年龄，性别，职业，邮编）</li></ul></li></ol><p>以下是数据的简要说明。</p><hr><blockquote><p>ml-data.tar.gz - 压缩的tar文件。要重建u数据文件，请执行以下操作：gunzip ml-data.tar.gz tar xvf ml-data.tar mku.sh<br>u.data - 完整的u数据集，984个用户对1682项的100000评级。每位用户至少评了20部电影。用户和项目从1开始连续编号。数据是随机排序的。这是一个以制表符分隔的用户ID列表 项目ID | 评级| 时间戳。时间戳是自1970年1月1日UTC以来的unix秒<br>u.info - u数据集中的用户，项目和评级数。<br>u.item - 有关项目（电影）的信息; 这是一个以标签分隔的电影ID列表 电影片名| 发布日期| 视频发布日期| IMDb URL | 未知| 行动| 冒险| 动画| 儿童| 喜剧| 犯罪| 纪录片| 戏剧| 幻想| 电影黑色| 恐怖| 音乐| 神秘| 浪漫| 科幻| 惊悚片| 战争| 西方| 最后19个字段是流派，1表示电影属于该类型，0表示不是; 电影可以同时使用多种类型。电影ID是u.data数据集中使用的。<br>u.genre - 类型列表。<br>u.user - 有关用户的人口统计信息; 这是一个以制表符分隔的用户ID列表 年龄| 性别| 职业| 邮政编码用户ID是u.data数据集中使用的ID。<br>u.occupation - 职业列表。<br>u1.base - 数据集u1.base和u1.test通过u5.base和u5.test u1.test将u数据的80％/ 20％拆分为训练和测试数据。u2.base u1，…，u5中的每一个都有不相交的测试集; 这个如果用于u2.test 5折交叉验证（在那里你用每个训练和测试集重复你的实验u3.base并平均结果）。u3.test这些数据集可以通过mku.sh从u.data生成。u4.base u4.test u5.base u5.test<br>ua.base - 数据集ua.base，ua.test，ub.base和ub.test ua.test将u数据分成训练集和ub.base的测试集，每个用户只有10个等级测试集。集合ub.test ua.test和ub.test是不相交的。这些数据集可以通过mku.sh从u.data生成。<br>allbut.pl - 生成训练和测试集的脚本，其中除了n个用户评级之外的所有评级都在训练数据中。<br>mku.sh - 用于从u.data生成所有u数据集的shell脚本。  </p></blockquote><h3 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h3><pre><code># 读取数据mydata&lt;-read.table(&quot;D:\\r语言\\ml-100k\\u.data&quot;,header = FALSE,stringsAsFactors = TRUE)# stringAsFactor=TRUE 表示表中的所有列都不是因子，是数值型数据</code></pre><p>第一列为用户ID，第二列电影ID，第三列是评分，第四列是用户评分的时间。这些在数据介绍中都要介绍。用户的评论时间对我们的分析没有用处，因此我们可以删掉这一列。</p><pre><code>mydata&lt;-mydata[,-4]</code></pre><p>现在这份数据集只有三列。</p><p>使用ggplot2分析用户对电影的评分结果。</p><p>要使用饼图来展现出结果，这样可以很好的展现评分列的分布特点。  </p><pre><code>ggplot(mydata,x=V3,aes(x=factor(1),fill=factor(V3)))+geom_bar(width = 1)+  coord_polar(theta=&quot;y&quot;)+ggtitle(&quot;评分分布图&quot;)+  labs(x=&quot;&quot;,y=&quot;&quot;)+  guides(fill=guide_legend(title = &#39;评分分数&#39;))</code></pre><p><img src="https://img-blog.csdn.net/20171203151748893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQyOTU1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt>  </p><p>由图可知，评分为一分，两分的特别少，用户给出三分，四分的比较多，占了三分之二多。当一个新电影的评分低于3.5分时，差不多就失去了一半的用户。使用reshape包对数据进行处理，生成一个v1*v2，v3值的填充矩阵。  </p><pre><code>mydata&lt;-cast(mydata,V1~V2,value=&quot;V3&quot;) #生成一个以v1为行，v2为列的矩阵，使用v3进行填充mydata&lt;-mydata[,-1] #第一列数字为序列，剔除</code></pre><p>这个时候，mydata有两个属性值cast_df 和data.frame。cast_df就类似Excel中的透视表；我们要将mydata属性改为数据框，其中cast_df是不能直接转换为matrix的，因此需要去掉这个类属性，只保留data.frame。  </p><pre><code>mydata&lt;-as.data.frame(mydata)dim(mydata)  #输出行列数  [1]  943 1682</code></pre><p>接下来，我们仍要对数据进行处理，使之转换成recommenderlab包可以处理的realRatingMatrix属性。在下面，我们首先将mydata转化为一个矩阵，然后使用as()函数，进行强制类型转换，达到了我们要的结果。我们还需要给我每列数据命名，否则后面建模会出现报错</p><pre><code>mydata&lt;-as.matrix(mydata)mydata&lt;-as(mydata,&quot;realRatingMatrix&quot;)  #生成一个 943*1682 realRatingMatrix类型的矩阵，包括了100000条记录 colnames(mydata)&lt;-paste0(&quot;movie&quot;,1:1682,sep=&quot;&quot;)#利用paste0给电影编号起名</code></pre><h3 id="三、建立模型"><a href="#三、建立模型" class="headerlink" title="三、建立模型"></a>三、建立模型</h3><p>在recommenderlab包里面，针对realRatingMatrix数据类型，总共提供了6种模型，分别是：基于项目协同过滤（IBCF）， 主成分分析（PCA）， 基于流行度推荐（POPULAR）,随机推荐（RANDOM）,奇异值分解（SVD），基于用户协同过滤算法（UBCF）。  </p><ul><li><p>协同过滤主要有两个步骤：  </p><ul><li><p>①依据目标用户的已知电影评分找到与目标用户观影风格相似的用户群。  </p></li><li><p>②计算该用户群对其他电影的评分，并作为目标用户的预测评分。  </p></li></ul></li></ul><p>这份数据是943位用户对1682部电影的一个评分，但每个人不可能将这些电影全都看完，而且不可能对所有看过的电影进行评分，因此我们我们刚刚生成的评分矩阵是一个非常稀疏，而且含有许多缺失值的矩阵。但这些并不影响协同过滤的工作效果。所以我们选择了协同过滤来建立我们的模型。</p><h5 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h5><pre><code>mydata.model &lt;- Recommender( mydata[1:943], method = &quot;UBCF&quot;)</code></pre><h6 id="预测1"><a href="#预测1" class="headerlink" title="预测1"></a>预测1</h6><pre><code>mydata.predict &lt;- predict(mydata.model,mydata[100:110], type=&quot;ratings&quot;)    as(mydata.predict,&quot;matrix&quot;)[1:4,1000:1005]</code></pre><hr><pre><code>    movie1000 movie1001 movie1002 movie1003 movie1004 movie1005100  3.067797  3.043630  3.067797  3.067797  3.067797  3.067797101  2.895522  2.895522  2.895522  2.895522  2.895522  2.895522102  2.615741  2.615741  2.615741  2.615741  2.615741  2.535489103  3.620690  3.620690  3.620690  3.620690  3.620690  3.620690</code></pre><ul><li>用户100~103 对电影 1000~1005 预测评分。</li></ul><hr><h6 id="预测2"><a href="#预测2" class="headerlink" title="预测2"></a>预测2</h6><pre><code>mydata.predict1&lt;-predict(mydata.model,mydata[10:15],n=5)as(mydata.predict1,&quot;list&quot;)   </code></pre><hr><pre><code>$`10`[1] &quot;movie313&quot; &quot;movie300&quot; &quot;movie222&quot; &quot;movie311&quot; &quot;movie405&quot;$`11`[1] &quot;movie285&quot; &quot;movie315&quot; &quot;movie302&quot; &quot;movie313&quot; &quot;movie269&quot;$`12`[1] &quot;movie313&quot; &quot;movie100&quot; &quot;movie288&quot; &quot;movie268&quot; &quot;movie316&quot;$`13`[1] &quot;movie134&quot; &quot;movie513&quot; &quot;movie169&quot; &quot;movie660&quot; &quot;movie408&quot;$`14`[1] &quot;movie300&quot; &quot;movie258&quot; &quot;movie272&quot; &quot;movie887&quot; &quot;movie286&quot;$`15`[1] &quot;movie183&quot; &quot;movie100&quot; &quot;movie172&quot; &quot;movie98&quot;  &quot;movie197&quot;</code></pre><p>修改一下参数，给用户推荐电影。预测2为给用户10~15 推荐5部电影</p><h3 id="四、协同过滤"><a href="#四、协同过滤" class="headerlink" title="四、协同过滤"></a>四、协同过滤</h3><ol><li><p>什么是协同过滤</p><p> 协同过滤是利用集体智慧的一个典型方法。要理解什么是协同过滤 (Collaborative Filtering, 简称 CF)，首先想一个简单的问题，如果你现在想看个电影，但你不知道具体看哪部，你会怎么做？大部分的人会问问周围的朋友，看看最近有什么好看的电影推荐，而我们一般更倾向于从口味比较类似的朋友那里得到推荐。这就是协同过滤的核心思想。</p><p> 换句话说，就是借鉴和你相关人群的观点来进行推荐，很好理解。</p></li><li><p>协同过滤的实现</p><p> 收集数据——找到相似用户和物品——进行推荐</p></li></ol><ul><li><p>收集数据</p><p>  这里的数据指的都是用户的历史行为数据，比如用户的购买历史，关注，收藏行为，或者发表了某些评论，给某个物品打了多少分等等，这些都可以用来作为数据供推荐算法使用，服务于推荐算法。需要特别指出的在于，不同的数据准确性不同，粒度也不同，在使用时需要考虑到噪音所带来的影响。</p></li><li><p>找到相似用户和物品<br>  这一步也很简单，其实就是计算用户间以及物品间的相似度。以下是几种计算相似度的方法：</p><blockquote><p>欧式距离<br>皮尔逊相关系数<br>Cosine 相似度<br>Tanimoto 系数</p></blockquote></li><li><p>进行推荐</p><p>  在知道了如何计算相似度后，就可以进行推荐了</p><p>  在协同过滤中，有两种主流方法：基于用户的协同过滤，和基于物品的协同过滤。</p><ul><li><p>基于用户的 CF 的基本思想相当简单，基于用户对物品的偏好找到相邻邻居用户，然后将邻居用户喜欢的推荐给当前用户。计算上，就是将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，找到 K 邻居后，根据邻居的相似度权重以及他们对物品的偏好，预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表作为推荐。</p></li><li><p>基于物品的 CF 的原理和基于用户的 CF 类似，只是在计算邻居时采用物品本身，而不是从用户的角度，即基于用户对物品的偏好找到相似的物品，然后根据用户的历史偏好，推荐相似的物品给他。从计算的角度看，就是将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度，得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有表示偏好的物品，计算得到一个排序的物品列表作为推荐。</p></li></ul></li></ul><ol start="3"><li><p>总结</p><blockquote><p>以上两个方法都能很好的给出推荐，并可以达到不错的效果。但是他们之间还是有不同之处的，而且适用性也有区别。下面进行一下对比</p></blockquote><ul><li><p>计算复杂度 </p><p>  Item CF 和 User CF 是基于协同过滤推荐的两个最基本的算法，User CF 是很早以前就提出来了，Item CF 是从 Amazon 的论文和专利发表之后（2001 年左右）开始流行，大家都觉得 Item CF 从性能和复杂度上比 User CF 更优，其中的一个主要原因就是对于一个在线网站，用户的数量往往大大超过物品的数量，同时物品的数据相对稳定，因此计算物品的相似度不但计算量较小，同时也不必频繁更新。但我们往往忽略了这种情况只适应于提供商品的电子商务网站，对于新闻，博客或者微内容的推荐系统，情况往往是相反的，物品的数量是海量的，同时也是更新频繁的，所以单从复杂度的角度，这两个算法在不同的系统中各有优势，推荐引擎的设计者需要根据自己应用的特点选择更加合适的算法。</p></li><li><p>适用场景 </p><p>  在非社交网络的网站中，内容内在的联系是很重要的推荐原则，它比基于相似用户的推荐原则更加有效。比如在购书网站上，当你看一本书的时候，推荐引擎会给你推荐相关的书籍，这个推荐的重要性远远超过了网站首页对该用户的综合推荐。可以看到，在这种情况下，Item CF 的推荐成为了引导用户浏览的重要手段。同时 Item CF 便于为推荐做出解释，在一个非社交网络的网站中，给某个用户推荐一本书，同时给出的解释是某某和你有相似兴趣的人也看了这本书，这很难让用户信服，因为用户可能根本不认识那个人；但如果解释说是因为这本书和你以前看的某本书相似，用户可能就觉得合理而采纳了此推荐。</p><p>  相反的，在现今很流行的社交网络站点中，User CF 是一个更不错的选择，User CF 加上社会网络信息，可以增加用户对推荐解释的信服程度。</p></li></ul></li></ol><h3 id="五、引伸"><a href="#五、引伸" class="headerlink" title="五、引伸"></a>五、引伸</h3><blockquote><p>试着将基于用户协同过滤算法（UBCF），换成基于项目协同过滤（IBCF）,建模用时更长</p></blockquote><h5 id="建立模型-1"><a href="#建立模型-1" class="headerlink" title="建立模型"></a>建立模型</h5><pre><code>mydata.model &lt;- Recommender( mydata[1:943], method = &quot;IBCF&quot;)</code></pre><h6 id="预测1-1"><a href="#预测1-1" class="headerlink" title="预测1"></a>预测1</h6><pre><code>mydata.predict &lt;- predict(mydata.model,mydata[100:110], type=&quot;ratings&quot;)    as(mydata.predict,&quot;matrix&quot;)[1:4,1000:1005]</code></pre><hr><pre><code>    movie1000 movie1001 movie1002 movie1003 movie1004 movie1005100        NA         2         3  4.000000        NA        NA101         2        NA        NA  2.500000         4        NA102         2        NA         3  2.666667         3         3103        NA        NA        NA  2.000000        NA        NA</code></pre><ul><li>用户100~103 对电影 1000~1005 预测评分。</li></ul><hr><h6 id="预测2-1"><a href="#预测2-1" class="headerlink" title="预测2"></a>预测2</h6><pre><code>mydata.predict1&lt;-predict(mydata.model,mydata[10:15],n=5)as(mydata.predict1,&quot;list&quot;)   </code></pre><hr><pre><code>    $`10`[1] &quot;movie75&quot;  &quot;movie327&quot; &quot;movie339&quot; &quot;movie360&quot; &quot;movie379&quot;$`11`[1] &quot;movie18&quot;  &quot;movie68&quot;  &quot;movie113&quot; &quot;movie292&quot; &quot;movie316&quot;$`12`[1] &quot;movie37&quot;  &quot;movie360&quot; &quot;movie537&quot; &quot;movie723&quot; &quot;movie766&quot;$`13`[1] &quot;movie16&quot;  &quot;movie30&quot;  &quot;movie46&quot;  &quot;movie104&quot; &quot;movie112&quot;$`14`[1] &quot;movie37&quot;  &quot;movie41&quot;  &quot;movie74&quot;  &quot;movie115&quot; &quot;movie256&quot;$`15`[1] &quot;movie43&quot;  &quot;movie51&quot;  &quot;movie52&quot;  &quot;movie107&quot; &quot;movie114&quot;</code></pre><p>修改一下参数，给用户推荐电影。预测2为给用户10~15 推荐5部电影</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/index.html" target="_blank" rel="noopener">深入推荐引擎相关算法 - 协同过滤</a></p></li><li><p><a href="https://www.cnblogs.com/luban/p/8950350.html" target="_blank" rel="noopener">推荐系统：基于用户和模型的协同过滤电影推荐</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言字符串处理</title>
      <link href="/2019/05/18/r/r-yu-yan-zi-fu-chuan-chu-li/"/>
      <url>/2019/05/18/r/r-yu-yan-zi-fu-chuan-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="R语言中的字符串处理函数"><a href="#R语言中的字符串处理函数" class="headerlink" title="R语言中的字符串处理函数"></a>R语言中的字符串处理函数</h1><h3 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h3><p>  尽管R是一门以数值向量和矩阵为核心的统计语言，但字符串有时候也会在数据分析中占到相当大的份量。</p><ul><li><p>获取字符串长度：nchar()能够获取字符串的长度，它也支持字符串向量操作。注意它和length()的结果是有区别的。</p></li><li><p>字符串粘合：paste()负责将若干个字符串相连结，返回成单独的字符串。其优点在于，就算有的处理对象不是字符型也能自动转为字符型。</p></li><li><p>字符串分割：strsplit()负责将字符串按照某种分割形式将其进行划分，它正是paste()的逆操作。</p></li><li><p>字符串截取：substr()能对给定的字符串对象取出子集，其参数是子集所处的起始和终止位置。</p></li><li><p>字符串替代：gsub()负责搜索字符串的特定表达式，并用新的内容加以替代。sub()函数是类似的，但只替代第一个发现结果。</p></li><li><p>字符串匹配：grep()负责搜索给定字符串对象中特定表达式 ，并返回其位置索引。grepl()函数与之类似，但其后面的”l”则意味着返回的将是逻辑值。</p></li><li><p>字符(串)的格式化(定制)输出：R中将字符或字符串按照一定的格式和要求输出。</p><pre><code>字符串分割函数：strsplit()字符串连接函数：paste()及paste0()计算字符串长度：nchar()及length()字符串截取函数：substr()及substring()字符串替换函数：chartr()、sub()及gsub()字符串匹配函数：grep()及grepl()大小写转换函数：toupper()、tolower()及casefold()字符(串)的格式化(定制)输出函数：sprintf()、sink()、cat()、print()、strtrim()、strwrap()</code></pre></li></ul><h2 id="字符串函数参数详解及示例"><a href="#字符串函数参数详解及示例" class="headerlink" title="字符串函数参数详解及示例"></a>字符串函数参数详解及示例</h2><hr><h4 id="1-字符串分割函数：strsplit"><a href="#1-字符串分割函数：strsplit" class="headerlink" title="1. 字符串分割函数：strsplit()"></a>1. 字符串分割函数：strsplit()</h4><p>  strsplit()是一个拆分函数，该函数可以使用正则表达式进行匹配拆分。</p><p>    其命令形式为：<strong>strsplit(x, split, fixed= F, perl= F, useBytes= F)</strong></p><p>  在R里面，strsplit一般用来进行字符串分割操作，我们先来看下strsplit函数有哪些选项：<strong>x、split、fixed、perl</strong> 这四个选项是我们会经常用到的。</p><ul><li><p>参数x为字符串格式向量，函数依次对向量的每个元素进行拆分</p></li><li><p>参数split为拆分位置的字串向量，即在哪个字串处开始拆分；该参数默认是正则表达式匹配；若设置fixed= T则表示是用普通文本匹配或者正则表达式的精确匹配。用普通文本来匹配的运算速度要快些。</p></li><li><p>参数perl的设置和perl的版本有关，表示可以使用perl语言里面的正则表达式。如果正则表达式过长，则可以考虑使用perl的正则来提高运算速度。</p></li><li><p>参数useBytes表示是否逐字节进行匹配，默认为FALSE，表示是按字符匹配而不是按字节进行匹配。</p></li><li><p><strong>Example1</strong></p><blockquote><p>strsplit()函数用于字符串分割，其中split是分割参数。所得结果以默认以list形式展示。<br>首先x和split是两个必须的选项</p></blockquote><pre><code>&gt; x = &quot;character vector, each element of which is to be split. Other inputs, including a factor, will give an error.&quot;&gt; x[1] &quot;character vector, each element of which is to be split. Other inputs, including a factor, will give an error.&quot;&gt; strsplit(x,split = &quot;\\s+&quot;)[[1]] [1] &quot;character&quot; &quot;vector,&quot;   &quot;each&quot;      &quot;element&quot;   &quot;of&quot;        &quot;which&quot;     &quot;is&quot;        &quot;to&quot;        &quot;be&quot;        &quot;split.&quot;    &quot;Other&quot;    [12] &quot;inputs,&quot;   &quot;including&quot; &quot;a&quot;         &quot;factor,&quot;   &quot;will&quot;      &quot;give&quot;      &quot;an&quot;        &quot;error.&quot;   &gt; strsplit(x,split = &quot; &quot;)[[1]] [1] &quot;character&quot; &quot;vector,&quot;   &quot;each&quot;      &quot;element&quot;   &quot;of&quot;        &quot;which&quot;     &quot;is&quot;        &quot;to&quot;        &quot;be&quot;        &quot;split.&quot;    &quot;Other&quot;    [12] &quot;inputs,&quot;   &quot;including&quot; &quot;a&quot;         &quot;factor,&quot;   &quot;will&quot;      &quot;give&quot;      &quot;an&quot;        &quot;error.&quot;   &gt; strsplit(x,split = &quot;&quot;)[[1]]  [1] &quot;c&quot; &quot;h&quot; &quot;a&quot; &quot;r&quot; &quot;a&quot; &quot;c&quot; &quot;t&quot; &quot;e&quot; &quot;r&quot; &quot; &quot; &quot;v&quot; &quot;e&quot; &quot;c&quot; &quot;t&quot; &quot;o&quot; &quot;r&quot; &quot;,&quot; &quot; &quot; &quot;e&quot; &quot;a&quot; &quot;c&quot; &quot;h&quot; &quot; &quot; &quot;e&quot; &quot;l&quot; &quot;e&quot; &quot;m&quot; &quot;e&quot; &quot;n&quot; &quot;t&quot; &quot; &quot; &quot;o&quot; &quot;f&quot; &quot; &quot; &quot;w&quot; [36] &quot;h&quot; &quot;i&quot; &quot;c&quot; &quot;h&quot; &quot; &quot; &quot;i&quot; &quot;s&quot; &quot; &quot; &quot;t&quot; &quot;o&quot; &quot; &quot; &quot;b&quot; &quot;e&quot; &quot; &quot; &quot;s&quot; &quot;p&quot; &quot;l&quot; &quot;i&quot; &quot;t&quot; &quot;.&quot; &quot; &quot; &quot;O&quot; &quot;t&quot; &quot;h&quot; &quot;e&quot; &quot;r&quot; &quot; &quot; &quot;i&quot; &quot;n&quot; &quot;p&quot; &quot;u&quot; &quot;t&quot; &quot;s&quot; &quot;,&quot; &quot; &quot; [71] &quot;i&quot; &quot;n&quot; &quot;c&quot; &quot;l&quot; &quot;u&quot; &quot;d&quot; &quot;i&quot; &quot;n&quot; &quot;g&quot; &quot; &quot; &quot;a&quot; &quot; &quot; &quot;f&quot; &quot;a&quot; &quot;c&quot; &quot;t&quot; &quot;o&quot; &quot;r&quot; &quot;,&quot; &quot; &quot; &quot;w&quot; &quot;i&quot; &quot;l&quot; &quot;l&quot; &quot; &quot; &quot;g&quot; &quot;i&quot; &quot;v&quot; &quot;e&quot; &quot; &quot; &quot;a&quot; &quot;n&quot; &quot; &quot; &quot;e&quot; &quot;r&quot;[106] &quot;r&quot; &quot;o&quot; &quot;r&quot; &quot;.&quot;</code></pre></li></ul><blockquote><p>在上面的例子中我们可以看到，我们对split选项设置了三个不同的参数，第一个是<code>\\s+</code>，第二个是一个空格，第三个一个空字符。<br>第一个参数<code>\\s+</code>和第二个参数空格达到了相同的效果，都是把x字符串按照空白进行分割。那个这里为什么是<code>\\s+</code>呢？相信对正则表达式有一点了解的同学一定会知道<code>\s+</code>是什么意思。<code>\s+</code>是表示匹配一个或一个以上的空白字符，包括空格、制表符和换行符等。这里的第一个<code>\</code> 是用来转义第二个<code>\</code> 符号的。<br>那么第三个参数里面，我们设置 <code>split=&quot;&quot;</code> 又是什么意思呢？当设置为空字符的时候，<code>strsplit</code> 函数会把字符串按照字符一个个进行分割。</p></blockquote><ul><li><p><strong>Example2</strong></p><blockquote><p>strsplit默认支持正则表达式<br>在上面的例子中我们也可以看到strsplit默认是支持正则表达式的。<br>那么如果我要不支持正则表达式强行按照固定字符匹配怎么办呢？除了我们用更加高级的正则表达式达到这一目的我们还可以通过设定fixed参数来达到目的：</p></blockquote><pre><code>&gt; x = &quot;asdas\\sasdasd&quot;&gt; x[1] &quot;asdas\\sasdasd&quot;&gt; strsplit(x,split = &quot;\\s&quot;)[[1]][1] &quot;asdas\\sasdasd&quot;&gt; strsplit(x,split = &quot;\\s&quot;,fixed = T)[[1]][1] &quot;asdas&quot;  &quot;asdasd&quot;&gt; strsplit(x,split = &quot;\s&quot;)Error: &#39;\s&#39; is an unrecognized escape in character string starting &quot;&quot;\s&quot;</code></pre><blockquote><p>比如这里的 x 字符串，它带有两个<code>\</code>，我要以<code>\\s</code>来进行分割。如果我直接设定<code>split=&#39;\\s&#39;</code>参数时，<code>strsplit</code>函数无法正确的分割字符串，但是当我加了<code>fixed=T</code>参数后，<code>strsplit</code>函数可以正确分割这些字符串。<br>在strsplit函数中，是默认支持正则表达式的，我们可以通过设置perl来支持使用perl兼容的正则表达式。也可以通过fixed来设置不支持正则表达式，而且fixed选项拥有比perl更高的优先级。</p></blockquote></li><li><p><strong>Example3</strong></p><blockquote><p>fixed为TRUE表示精确匹配，否则表示可以使用正则表达式另外需要说明一点的是：直接使用split函数得到的结果是一个列表，如果希望得到一个向量，可以使用 unlist() 函数。</p></blockquote><pre><code># 由于split是正则表达式，所以在切割包含.的字符串的时候万分小心unlist(strsplit(&quot;a.b.c&quot;, &quot;.&quot;))## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;## following are right answersunlist(strsplit(&quot;a.b.c&quot;, &quot;[.]&quot;))## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;unlist(strsplit(&quot;a.b.c&quot;, &quot;.&quot;, fixed = TRUE))unlist(strsplit(&quot;a.b.c&quot;,&quot;\\.&quot;))## 编写逆写字符串## a useful function: rev() for stringsstrReverse &lt;- function(x)        sapply(lapply(strsplit(x, NULL), rev), paste, collapse = &quot;&quot;)strReverse(c(&quot;abc&quot;, &quot;Statistics&quot;))## 得到R核心团队成员的名First Name## get the first names of the members of R-corea &lt;- readLines(file.path(R.home(&quot;doc&quot;),&quot;AUTHORS&quot;))[-(1:8)]a &lt;- a[(0:2)-length(a)](a &lt;- sub(&quot; .*&quot;,&quot;&quot;, a))# and reverse themstrReverse(a)# 注意：最后一个空字符串将会被忽略strsplit(paste(c(&quot;&quot;, &quot;a&quot;, &quot;&quot;), collapse=&quot;#&quot;), split=&quot;#&quot;)[[1]]# [1] &quot;&quot;  &quot;a&quot;# split=NULL逐个切割字符串strsplit(&quot;abcde&quot;,NULL)</code></pre></li></ul><hr><h4 id="2-字符串连接函数：paste-及-paste0"><a href="#2-字符串连接函数：paste-及-paste0" class="headerlink" title="2. 字符串连接函数：paste() 及 paste0()"></a>2. 字符串连接函数：paste() 及 paste0()</h4><p>  主要参数： <strong>paste(…, sep = “ “, collapse = NULL)</strong></p><p>       <strong>paste0(…, collapse = NULL)</strong></p><p>  paste()函数用于字符串连接，其中 sep 负责两组字符串间的连接； collapse 负责一组字符串内部的连接，常常在一些作图的标题中看到paste的使用。</p><ul><li><p><strong>Example1</strong></p><blockquote><p>paste()函数可以将多个字符型向量连接成一个向量。如果要将一个不同类型的向量连接起来，这个向量首先会被转换成字符型向量。</p></blockquote><pre><code>&gt; x &lt;- c(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)&gt; y &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;,&quot;E&quot;)&gt; paste(x, y)[1] &quot;a A&quot; &quot;b B&quot; &quot;c C&quot; &quot;d D&quot; &quot;e E&quot;</code></pre></li><li><p><strong>Example2</strong></p><blockquote><p>在默认情况下，向量的值之间使用空格进行分隔的。 若想使用其他分隔符，可以使用sep参数进行设置，例如：</p></blockquote><pre><code>&gt; paste(x, y, sep = &quot;-&quot;)[1] &quot;a-A&quot; &quot;b-B&quot; &quot;c-C&quot; &quot;d-D&quot; &quot;e-E&quot;&gt; paste(x, y, sep = &quot;&quot;)[1] &quot;aA&quot; &quot;bB&quot; &quot;cC&quot; &quot;dD&quot; &quot;eE&quot;&gt; paste(letters[1:6],1:6,sep=&quot;-&quot;)[1] &quot;a-1&quot; &quot;b-2&quot; &quot;c-3&quot; &quot;d-4&quot; &quot;e-5&quot; &quot;f-6&quot;</code></pre></li><li><p><strong>Example3</strong></p><blockquote><p>若将返回的所有向量都连成一个字符串，那么则需要collapse参数来指定这些值之间的连接符。例如：</p></blockquote><pre><code>&gt; paste(x, y, sep = &quot;-&quot;, collapse = &quot;#&quot;)[1] &quot;a-A#b-B#c-C#d-D#e-E&quot;&gt; paste(letters[1:6],1:6,sep=&quot;-&quot;,collapse=&quot;;&quot;)[1] &quot;a-1;b-2;c-3;d-4;e-5;f-6&quot;&gt; nth &lt;- paste0(1:12, c(&quot;st&quot;, &quot;nd&quot;, &quot;rd&quot;, rep(&quot;th&quot;, 9)))&gt; paste(month.abb, &quot;is the&quot;, nth, &quot;month of the year.&quot;, sep = &quot;_*_&quot;)[1] &quot;Jan_*_is the_*_1st_*_month of the year.&quot;  &quot;Feb_*_is the_*_2nd_*_month of the year.&quot;[3] &quot;Mar_*_is the_*_3rd_*_month of the year.&quot;  &quot;Apr_*_is the_*_4th_*_month of the year.&quot;[5] &quot;May_*_is the_*_5th_*_month of the year.&quot;  &quot;Jun_*_is the_*_6th_*_month of the year.&quot;[7] &quot;Jul_*_is the_*_7th_*_month of the year.&quot;  &quot;Aug_*_is the_*_8th_*_month of the year.&quot;[9] &quot;Sep_*_is the_*_9th_*_month of the year.&quot;  &quot;Oct_*_is the_*_10th_*_month of the year.&quot;[11] &quot;Nov_*_is the_*_11th_*_month of the year.&quot; &quot;Dec_*_is the_*_12th_*_month of the year.&quot;</code></pre></li><li><p><strong>Example4</strong></p><blockquote><p>paste()在不指定分割符的情况下，默认分割符是空格；paste0()在不指定分割符的情况下，默认分割符是空。</p></blockquote><pre><code># 默认以空格隔开paste(&quot;Hello&quot;,&quot;world&quot;)[1] &quot;Hello world&quot;# 没有空格paste0(&quot;Hello&quot;,&quot;world&quot;)[1] &quot;Helloworld&quot;# 指定分割符paste(&quot;abc&quot;, &quot;efg&quot;, &quot;hijk&quot;, sep = &quot;-&quot;)[1] &quot;abc-efg-hijk&quot;# 分别对向量的每一个元素进行连接paste0(&quot;A&quot;, 1:6, sep = &quot;&quot;)[1] &quot;A1&quot; &quot;A2&quot; &quot;A3&quot; &quot;A4&quot; &quot;A5&quot; &quot;A6&quot;# collapse参数：每一个元素操作之后，再把向量的每一个元素进行连接paste0(&quot;A&quot;, 1:6, sep = &quot;&quot;,collapse = &quot;-&quot;)[1] &quot;A1-A2-A3-A4-A5-A6&quot;</code></pre></li></ul><hr><h4 id="3-计算字符串长度：nchar-及length"><a href="#3-计算字符串长度：nchar-及length" class="headerlink" title="3. 计算字符串长度：nchar()及length()"></a>3. 计算字符串长度：nchar()及length()</h4><p>  nchar()返回字符串的长度，取字符数量的函数。length与nchar不同，length是取向量的长度（nchar用于计算 x 中的字符数量，length函数返回 x 的集合长度）。</p><p>  用法：<strong>nchar(x, type = “chars”, allowNA = FALSE, keepNA = FALSE)</strong></p><p>  <strong>nzchar(x)</strong>用于判断一个变量的长度是否为0。</p><p>  需要注意的是，对于缺失值NA，nzchar()的结果为TRUE，而函数nchar()的返回结果为2。所以在对字符串进行测量之前，最好先使用is.na()函数判断一下是否是NA值。</p><ul><li><p><strong>Example</strong></p><pre><code>x &lt;- c(&quot;asfef&quot;, &quot;qwerty&quot;, &quot;yuiop[&quot;, &quot;b&quot;, &quot;stuff.blah.yech&quot;)&gt; nchar(x)# 5  6  6  1 15#现R语言设定为NA长度为2&gt; nchar(NA) ## [1] 2&gt; nzchar(NA)[1] TRUE&gt; x &lt;- &#39;&#39;&gt; nzchar(x)[1] FALSE&gt; nchar(&quot;你好&quot;,type=&quot;chars&quot;)   #默认情况## [1] 2&gt; nchar(&quot;你好&quot;,type=&quot;bytes&quot;)   #每个中文字符占2个bytes## [1] 4&gt; nchar(&quot;你好&quot;,type=&quot;width&quot;)## [1] 4&gt; m&lt;-&quot;who wins 123&quot;&gt; nchar(m)[1] 12&gt; length(m)[1] 1# nchar表示字符串中的字符的个数&gt; nchar(&quot;abcd&quot;)[1] 4# length表示向量中元素的个数&gt; length(&quot;abcd&quot;)[1] 1&gt; length(c(&quot;hello&quot;, &quot;world&quot;))[1] 2&gt; length(&quot;&quot;)  #虽然字符为空，但是它仍然是一个元素。[1] 1</code></pre></li></ul><hr><h4 id="4-字符串截取函数：substr-；substring"><a href="#4-字符串截取函数：substr-；substring" class="headerlink" title="4. 字符串截取函数：substr()；substring()"></a>4. 字符串截取函数：substr()；substring()</h4><p>  substr()函数和substring()函数是截取字符串最常用的函数，两个函数功能方面是一样的，只是其中参数设置不同。</p><p>  substr()函数：必须设置参数start和stop，如果缺少将出错。</p><p>  substring()函数：可以只设置first参数，last参数若不设置，则默认为1000000L，通常是指字符串的最大长度。</p><p>  <code>substr(x, start, stop)</code></p><p>  <code>substring(text, first, last = 1000000L)</code></p><p>  <code>substr(x, start, stop) &lt;- value</code></p><p>  <code>substring(text, first, last = 1000000L) &lt;- value</code></p><ul><li><p><strong>Example1</strong></p><blockquote><p>substr能够提取或替换一个字符向量中的子串或替换子字符串</p></blockquote><pre><code>&gt; substr(&#39;abcdef&#39;,2,4)[1] &quot;bcd&quot;&gt; substr(&quot;abcdef&quot;, 2, 4)   #两种表达方式等价[1] &quot;bcd&quot;&gt; x &lt;- &quot;abcdef&quot;&gt; substr(x, 1, 1) &lt;- &quot;ccc&quot;&gt; x[1] &quot;cbcdef&quot;&gt; x &lt;- &quot;abcdef&quot;&gt; substr(x, 1, 1) &lt;- &quot;&quot;&gt; x[1] &quot;abcdef&quot;&gt; x &lt;- &quot;abcdef&quot;&gt; substr(x, 1, 1) &lt;- &quot; &quot;&gt; x[1] &quot; bcdef&quot;&gt; #如果start大于字符串长度，则返回&quot;&quot;&gt; x &lt;- c(&quot;asfef&quot;, &quot;qwerty&quot;, &quot;yuiop[&quot;, &quot;b&quot;, &quot;stuff.blah.yech&quot;)&gt; substr(x, 2, 5)[1] &quot;sfef&quot; &quot;wert&quot; &quot;uiop&quot; &quot;&quot;     &quot;tuff&quot;&gt; m&lt;-&quot;who wins 123&quot;&gt; substr(m,1,8)[1] &quot;who wins&quot;&gt; substr(m,1,3)&lt;-&quot;Tom&quot;&gt; m[1] &quot;Tom wins 123&quot;</code></pre></li><li><p><strong>Example2</strong></p><blockquote><p>substring函数则可以对字符串向量进行提取或替换</p></blockquote><pre><code>&gt; substring(&#39;abcdef&#39;, 1, 6)[1] &quot;abcdef&quot;&gt; substring(&#39;abcdef&#39;, 1:6, 6)[1] &quot;abcdef&quot; &quot;bcdef&quot;  &quot;cdef&quot;  [4] &quot;def&quot;    &quot;ef&quot;     &quot;f&quot;  ### 切割字符串另类方法，但速度不如strsplit&gt;substring(&#39;abcdef&#39;,1：6，1：6)[1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot;### 替换字符串向量中的部分元素&gt; x &lt;- c(&quot;asfef&quot;, &quot;qwerty&quot;, &quot;yuiop[&quot;, &quot;b&quot;, &quot;stuff.blah.yech&quot;)### 由于x长度为5，赋值向量会循环补齐，相当于 c(&quot;..&quot;, &quot;+++&quot;, &quot;..&quot;, &quot;+++&quot;, &quot;..&quot;)### substring(x, 2) &lt;- c(&quot;..&quot;, &quot;+++&quot;, &quot;..&quot;, &quot;+++&quot;, &quot;..&quot;)&gt; substring(x, 2) &lt;- c(&quot;..&quot;, &quot;+++&quot;)&gt; x[1] &quot;a..ef&quot;           &quot;q+++ty&quot;         [3] &quot;y..op[&quot;          &quot;b&quot;              [5] &quot;s..ff.blah.yech&quot;</code></pre></li><li><p><strong>Example3</strong></p><blockquote><p>两者的一些区别：substr返回的字串个数等于第一个参数的长度，而substring返回字串个数等于三个参数中最长向量长度，短向量循环使用。</p></blockquote><pre><code>&gt; substr(&quot;abcdef&quot;, 1:6, 1:6) [1] &quot;a&quot;#注意还有一个substring函数，效果就不一样了：&gt; substring(&quot;abcdef&quot;,1:6,1:6) [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot;#等价于：substr(&quot;123456789&quot;, 2, 4)&gt; substr(&quot;123456789&quot;, c(2, 3), c(4, 5, 6))  [1] &quot;234&quot;#最长的向量长度为3，其它向量都循环补齐&gt; substring(&quot;123456789&quot;, c(2, 3), c(4,5,6)) [1] &quot;234&quot;   &quot;345&quot;   &quot;23456&quot;</code></pre></li></ul><hr><h4 id="5-字符串替换函数：chartr-、sub-及gsub"><a href="#5-字符串替换函数：chartr-、sub-及gsub" class="headerlink" title="5. 字符串替换函数：chartr()、sub()及gsub()"></a>5. 字符串替换函数：chartr()、sub()及gsub()</h4><p>  chartr()函数：将原有字符串中特定字符替换成所需要的字符。其中参数old 表示原有字符串中内容；new 表示替换后的字符内容。</p><p>  <strong>chartr (old,new,x)</strong>，chartr-将对象中旧的字符用新的字符替代。</p><p>  这种功能和shell里面的rename有点类似，但old的字符数不能大于new，new字符数大于old的字符也将会被忽略，相当于重命名的意思。不同于rename的是chartr不能随意的替换字符串，用起来也有一定的局限性。</p><ul><li><p><strong>Example1</strong></p><pre><code>&gt; m&lt;-&quot;who wins 123&quot;&gt; chartr(&quot;w&quot;,&quot;W&quot;,m)[1] &quot;Who Wins 123&quot;&gt; chartr(old=&quot;a&quot;, new=&quot;c&quot;, x=&quot;a123&quot;)[1] &quot;c123&quot;&gt; chartr(old=&quot;a&quot;, new=&quot;A&quot;, x=&quot;data&quot;)[1] &quot;dAtA&quot;</code></pre></li><li><p><strong>Example2</strong></p><blockquote><p>gsub() 替换匹配到的全部；sub() 替换匹配到的第一个。</p></blockquote><blockquote><p>sub() 函数可以用来替换字符串。需要注意的是我们需要设置一个变量来接受这个替换操作后的字符，sub()函数不会对原变量进行操作。</p></blockquote><blockquote><p>######正则表达式解释######<br> /^\d+$/ 是正则表达式<br> ^和$用来匹配位置:^表示行首,$表示行尾<br> \d表示数字,即0-9<br> +表示重复1次以上<br> 综合起来,/^\d+$/ 这个正则表达式就是匹配一整行1个以上的数字<br> /^\d+$/ 就相当于 $<em>=~/^\d+$/<br> 就是对默认变量$</em>进行匹配,匹配成功就返回’真’,否则就返回’假’<br> !/^\d+$/ 就是对~/^\d+$/返回的布尔值取反<br>######正则表达式解释######</p></blockquote><pre><code>&gt; str &lt;- &quot;Now is the time      &quot;&gt; sub(&quot; +$&quot;, &quot; 12:00&quot;, str)  ## spaces only[1] &quot;Now is the time 12:00&quot;##几种错误写法##&gt; sub(&quot; +s&quot;, &quot; 12:00&quot;, str)[1] &quot;Now is the time      &quot;&gt; sub(&quot; &quot;, &quot; 12:00&quot;, str)[1] &quot;Now 12:00is the time      &quot;&gt; sub(&quot;     &quot;, &quot; 12:00&quot;, str)[1] &quot;Now is the time 12:00 &quot;# 将b替换为B&gt; gsub(pattern = &quot;b&quot;, replacement = &quot;B&quot;, x = &quot;baby&quot;)[1] &quot;BaBy&quot;&gt; gsub(pattern = &quot;b&quot;, replacement = &quot;B&quot;, x = c(&quot;abcb&quot;, &quot;boy&quot;, &quot;baby&quot;))[1] &quot;aBcB&quot; &quot;Boy&quot;  &quot;BaBy&quot;# 只替换第一个b&gt; sub(pattern = &quot;b&quot;, replacement = &quot;B&quot;, x = &quot;baby&quot;)[1] &quot;Baby&quot;&gt; sub(pattern = &quot;b&quot;, replacement = &quot;B&quot;, x = c(&quot;abcb&quot;, &quot;baby&quot;))[1] &quot;aBcb&quot; &quot;Baby&quot;</code></pre></li></ul><hr><h4 id="6-字符串匹配函数：grep-及grepl"><a href="#6-字符串匹配函数：grep-及grepl" class="headerlink" title="6. 字符串匹配函数：grep()及grepl()"></a>6. 字符串匹配函数：grep()及grepl()</h4><p>  其表达式为：</p><p>  <strong>grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,fixed = FALSE, useBytes = FALSE, invert = FALSE)</strong></p><p>  <strong>grepl(pattern, x, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)</strong></p><p>  可以理解为搜索字符向量中匹配参数pattern的模型，fixed的逻辑值决定将pattern视为正则表达式或一个文本字符串，若fixed=TURE，则视pattern为文本字符串（精确匹配）；fixed=FALSE，则视之为正则表达式，正则表达式则相当于一种条件，函数返回匹配值的下标；perl=TURE，使用perl风格的正则表达式；value则决定返回的类型是匹配值的下标还是匹配的值。</p><ul><li><p><strong>Example1</strong></p><pre><code>&gt; x = &quot;Hello World&quot;&gt; grep(pattern = &quot;Hello&quot;,x = x)[1] 1&gt; grep(pattern = &quot;l&quot;,x = x)[1] 1&gt; grepl(pattern = &quot;l&quot;,x = x)[1] TRUE</code></pre></li><li><p><strong>Example2</strong></p><blockquote><p>grep和grepl的区别在于grep返回的是匹配正确的字符串在 x 向量中的元素下标。而grepl返回的则是逻辑变量TRUE和ALSE。<br>如果我们想要返回匹配正确字符的值要怎么办呢？我们可以通过设置grep中的value=T来达到目的。如：</p></blockquote><pre><code>&gt; x = c(&quot;Hello&quot;,&quot;Bye&quot;,&quot;Hi&quot;)&gt; grep(pattern = &quot;l&quot;,x = x,value = T)[1] &quot;Hello&quot;&gt; grep(pattern = &quot;H&quot;,x = x,value = T)[1] &quot;Hello&quot; &quot;Hi&quot;   &gt; grep(pattern = &quot;H&quot;,x = x,value = F)[1] 1 3</code></pre></li><li><p><strong>Example3</strong></p><blockquote><p>在grep和grepl中，fixed和perl两个参数的用法跟strsplit中的用法是一致的。<br>正则表达式中，“[a-z]”就表示匹配a～z，所以[a-f]表示匹配正则表达式前面6个</p></blockquote><pre><code>&gt; grep(&quot;[a-f]&quot;,letters)      [1] 1 2 3 4 5 6 </code></pre></li><li><p><strong>Example4</strong></p><blockquote><p>使用fixed=T,因为我们匹配的类型是精确匹配，so</p></blockquote><pre><code>&gt;grep(&quot;[a-f]&quot;,letters,fixed=T)      integer(0)    #精确匹配中，[a-f]代表的是字符，所以就不能匹配到</code></pre></li><li><p><strong>Example5</strong></p><blockquote><p>匹配的 fixed 默认为F，这也提示我们应尽量的去使用正则表达式去匹配</p></blockquote><pre><code>&gt; txt &lt;- c(&quot;arm&quot;,&quot;foot&quot;,&quot;lefroo&quot;, &quot;bafoobar&quot;)&gt; grep(&quot;foo&quot;,txt)[1] 2 4</code></pre></li><li><p><strong>Example6</strong></p><blockquote><p>ignore.case 决定匹配是否对大小写敏感，为了达到精确匹配，默认为对大小写敏感；你完全可以设置不敏感，比如一些开头字母大写的问题。例如：</p></blockquote><pre><code>&gt; grep(&quot;Foo&quot;,txt)integer(0)&gt; grep(&quot;Foo&quot;,txt,ignore.case=TRUE)[1] 2 4&gt; grep(&quot;Foo&quot;,txt,ignore.case=T,value=T)[1] &quot;foot&quot;     &quot;bafoobar&quot;</code></pre></li><li><p><strong>Example7</strong></p><blockquote><p>invert 参数非常实用，它决定返回的的是匹配值还是非匹配值，往往我们要的结果就是非匹配值，例如在众多的邮件中根据内容不含”xxx”进行保留。</p></blockquote><pre><code>&gt; grep(&quot;Foo&quot;,txt,ignore.case=T,invert=T,value=T)[1] &quot;arm&quot;    &quot;lefroo&quot;</code></pre></li><li><p><strong>Example8</strong></p><blockquote><p>grepl函数与grep函数不同的地方在于返回的形式是否为布尔值（是 true 或 false 中的一个），grepl返回TURE或者FALSE，而grep函数返回匹配值下标或者匹配值本身，使用什么函数要看我们的需要。</p></blockquote><pre><code>&gt; grepl(&quot;Foo&quot;,txt,ignore.case=T)[1] FALSE  TURE FALSE  TURE</code></pre></li></ul><hr><h4 id="7-大小写替换函数：toupper-、tolower-、casefold"><a href="#7-大小写替换函数：toupper-、tolower-、casefold" class="headerlink" title="7. 大小写替换函数：toupper()、tolower()、casefold()"></a>7. 大小写替换函数：toupper()、tolower()、casefold()</h4><p>  toupper()函数：将字符串统一转换为大写。</p><p>  tolower()函数：将字符串统一转换为小写。</p><p>  casefold()函数：根据参数转换大小写。</p><p>  <code>tolower(x)</code></p><p>  <code>toupper(x)</code></p><p>  <code>casefold(x, upper = FALSE)</code></p><p>  <code>chartr(old, new, x)</code></p><ul><li><p><strong>Example</strong></p><blockquote><p>这两个函数就不用多介绍了，按字面意思就是把对象转换成大写或小写，应用于全部的对象，例如：</p></blockquote><pre><code>&gt;toupper(&quot;abc&quot;)[1]&quot;ABC&quot;&gt;tolower(&quot;ABC&quot;)[1]&quot;abc&quot;&gt;x&lt;-c(&quot;My&quot;,&quot;First&quot;,&quot;Trip&quot;)&gt;tolower(x)[1] &quot;my&quot; &quot;first&quot; &quot;trip&quot;&gt; casefold(&#39;ABDATA&#39;, upper = FALSE)[1] &quot;abdata&quot;&gt; casefold(&#39;baorui&#39;, upper = FALSE)[1] &quot;baorui&quot;&gt; casefold(&#39;baorui&#39;, upper = TRUE)[1] &quot;BAORUI&quot;# 这里这只提供全部应用的大小写转换，部分转换可以参照函数chartr()。chartr(old, new, x)</code></pre></li></ul><hr><h4 id="8-字符-串-的格式化-定制-输出"><a href="#8-字符-串-的格式化-定制-输出" class="headerlink" title="8. 字符(串)的格式化(定制)输出"></a>8. 字符(串)的格式化(定制)输出</h4><ul><li><p><strong>字符格式化输出</strong></p><pre><code>使用%s替代字符变量a &lt;- &quot;string&quot;sprintf(&quot;This is where a %s goes.&quot;, a)# &quot;This is where a string goes.&quot;# 使用%d替代整数x &lt;- 8sprintf(&quot;Regular:%d&quot;, x)# &quot;Regular:8&quot;# Can print to take some number of characters, leading with spaces.sprintf(&quot;Leading spaces:%4d&quot;, x)# &quot;Leading spaces:   8&quot;# Can also lead with zeros instead.sprintf(&quot;Leading zeros:%04d&quot;, x)#&quot;Leading zeros:0008:&quot;#使用%f替代浮点数# %m.nf m为输出字符宽度，即最小包含的字符量。如果字符串没有达到m长度，那么可以通过补0或者空格，n表示小数的精度sprintf(&quot;%f&quot;, pi)         # &quot;3.141593&quot;sprintf(&quot;%.3f&quot;, pi)       # &quot;3.142&quot;sprintf(&quot;%1.0f&quot;, pi)      # &quot;3&quot;sprintf(&quot;%5.1f&quot;, pi)      # &quot;  3.1&quot;sprintf(&quot;%05.1f&quot;, pi)     # &quot;003.1&quot;sprintf(&quot;%+f&quot;, pi)        # &quot;+3.141593&quot;sprintf(&quot;% f&quot;, pi)        # &quot; 3.141593&quot;sprintf(&quot;%-10f&quot;, pi)      # &quot;3.141593  &quot;   (left justified)sprintf(&quot;%e&quot;, pi)         #&quot;3.141593e+00&quot;sprintf(&quot;%E&quot;, pi)         # &quot;3.141593E+00&quot;sprintf(&quot;%g&quot;, pi)         # &quot;3.14159&quot;sprintf(&quot;%g&quot;,   1e6 * pi) # &quot;3.14159e+06&quot;  (exponential)sprintf(&quot;%.9g&quot;, 1e6 * pi) # &quot;3141592.65&quot;   (&quot;fixed&quot;)sprintf(&quot;%G&quot;, 1e-6 * pi)  # &quot;3.14159E-06&quot;x &lt;- &quot;string&quot;sprintf(&quot;Substitute in multiple strings: %s %s&quot;, x, &quot;string2&quot;)# &quot;Substitute in multiple strings: string string2&quot;# To print a percent sign, use &quot;%%&quot;sprintf(&quot;A single percent sign here %%&quot;)# &quot;A single percent sign here %&quot;#写入文件，重定向sink()#sink()重定向文件写入# Start writing to an output filesink(&#39;analysis-output.txt&#39;)set.seed(12345)x &lt;-rnorm(10,10,1)y &lt;-rnorm(10,11,1)# Do some stuff herecat (sprintf(&quot;x has %d elements:\n&quot;, length(x)))print(x)cat (&quot;y =&quot;, y, &quot;\n&quot;)cat(&quot;=============================\n&quot;)cat(&quot;T-test between x and y\n&quot;)cat(&quot;=============================\n&quot;)t.test(x,y)# Stop writing to the filesink()# Append to the filesink(&#39;analysis-output.txt&#39;, append=TRUE)cat(&quot;Some more stuff here...\n&quot;)sink()</code></pre></li><li><p><strong>字符串的定制输出</strong></p><p>  这个内容有点类似于字符串的连接。这里用到了strtrim()，用于将字符串修剪到特定的显示宽度，其命令形式如下：strtrim(x, width)该函数返回的字符串向量的长度等于参数x的长度。</p><pre><code>strtrim(c(&quot;abcde&quot;, &quot;abcde&quot;, &quot;abcde&quot;), c(1, 5, 10))## [1] &quot;a&quot;     &quot;abcde&quot; &quot;abcde&quot;strtrim(c(1, 123, 12345), 4)  #短向量循环## [1] &quot;1&quot;    &quot;123&quot;  &quot;1234&quot;</code></pre><p>  strtrim()会根据width参数提供的数字来修剪字符串，若width提供的数字大于字符串的字符数的话，则该字符串会保持原样，不会增加空格之类的东西。</p><p>  strwrap()会把字符串当成一个段落来处理（不管段落中是否有换行），按照段落的格式进行缩进和分行，返回结果就是一行行的字符串，其命令形式如下：strwrap(x, width, indent= 0, exdent= 0, prefix= “”, simplify= T, initial= prefix)函数返回结果中的每一行的字符串中的字符数目等于参数width。</p><pre><code>string &lt;- &quot;Each character string in the input is first split into\n paragraphs (or lines containing whitespace only). The paragraphs are then formatted by breaking lines at word boundaries.&quot;string## [1] &quot;Each character string in the input is first split into\n paragraphs (or lines containing whitespace only). The paragraphs are then formatted by breaking lines at word boundaries.&quot;cat(string)## Each character string in the input is first split into##  paragraphs (or lines containing whitespace only). The paragraphs are then formatted by breaking lines at word boundaries.strwrap(string)  #直接将换行符忽略了## [1] &quot;Each character string in the input is first split into paragraphs&quot;## [2] &quot;(or lines containing whitespace only). The paragraphs are then&quot;   ## [3] &quot;formatted by breaking lines at word boundaries.&quot;strwrap(string, width = 40, indent = 4)  #首行缩进## [1] &quot;    Each character string in the input&quot;## [2] &quot;is first split into paragraphs (or&quot;    ## [3] &quot;lines containing whitespace only). The&quot;## [4] &quot;paragraphs are then formatted by&quot;      ## [5] &quot;breaking lines at word boundaries.&quot;strwrap(string, width = 40, exdent = 4)  #除了首行的其余行缩进## [1] &quot;Each character string in the input is&quot; ## [2] &quot;    first split into paragraphs (or&quot;   ## [3] &quot;    lines containing whitespace only).&quot;## [4] &quot;    The paragraphs are then formatted&quot; ## [5] &quot;    by breaking lines at word&quot;         ## [6] &quot;    boundaries.&quot;strwrap(string, width = 40, simplify = F)  # 返回结果是个列表，而不再是个字符串向量## [[1]]## [1] &quot;Each character string in the input is&quot;## [2] &quot;first split into paragraphs (or lines&quot;## [3] &quot;containing whitespace only). The&quot;     ## [4] &quot;paragraphs are then formatted by&quot;     ## [5] &quot;breaking lines at word boundaries.&quot;strwrap(string, width = 40, prefix = &quot;******&quot;)## [1] &quot;******Each character string in the&quot;    ## [2] &quot;******input is first split into&quot;       ## [3] &quot;******paragraphs (or lines containing&quot; ## [4] &quot;******whitespace only). The paragraphs&quot;## [5] &quot;******are then formatted by breaking&quot;  ## [6] &quot;******lines at word boundaries.&quot;</code></pre></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="http://rstudio-pubs-static.s3.amazonaws.com/13823_dbf87ac4114b44f8a4b4fbd2ea5ea162.html" target="_blank" rel="noopener">R中的普通文本处理-汇总</a></p></li><li><p><a href="http://yphuang.github.io/blog/2016/02/29/R-Regular-Expressions-And-String-Functions/" target="_blank" rel="noopener">R中的正则表达式及字符处理函数总结</a></p></li><li><p><a href="http://www.bkjia.com/ASPjc/965932.html" target="_blank" rel="noopener">字符串处理函数</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析——逻辑回归</title>
      <link href="/2019/05/16/shu-ju-fen-xi/luo-ji-hui-gui/"/>
      <url>/2019/05/16/shu-ju-fen-xi/luo-ji-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑回归模型–glm"><a href="#逻辑回归模型–glm" class="headerlink" title="逻辑回归模型–glm"></a>逻辑回归模型–glm</h2><h3 id="1-检查数据基本信息"><a href="#1-检查数据基本信息" class="headerlink" title="1. 检查数据基本信息"></a>1. 检查数据基本信息</h3><h3 id="2-检查数据缺失值情况"><a href="#2-检查数据缺失值情况" class="headerlink" title="2. 检查数据缺失值情况"></a>2. 检查数据缺失值情况</h3><h3 id="3-拆分训练集与测试集"><a href="#3-拆分训练集与测试集" class="headerlink" title="3. 拆分训练集与测试集"></a>3. 拆分训练集与测试集</h3><pre><code>#不放回随机抽样 二八分布con&lt;-sample(1:nrow(Data),nrow(Data)*0.8)#训练集trans&lt;-sample(Data[con,])#测试集test&lt;-sample(Data[-con,])</code></pre><h3 id="4-建模"><a href="#4-建模" class="headerlink" title="4. 建模"></a>4. 建模</h3><pre><code>#违约为本次模型的因变量y （0,1）glm &lt;- glm(违约 ~ .,family = binomial(link = logit), data = xunlian)summary(glm)</code></pre><hr><pre><code>Coefficients:         Estimate Std. Error z value Pr(&gt;|z|)    (Intercept) -1.629162   0.710890  -2.292 0.021922 *  信用卡负债   0.626542   0.123993   5.053 4.35e-07 ***其他负债     0.051847   0.084368   0.615 0.538863    地址        -0.095285   0.025975  -3.668 0.000244 ***负债率       0.069199   0.034297   2.018 0.043628 *  收入        -0.009108   0.008216  -1.109 0.267596    工龄        -0.254092   0.036482  -6.965 3.29e-12 ***教育         0.144198   0.140308   1.028 0.304080    年龄         0.033086   0.019592   1.689 0.091273 .  Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1---(Dispersion parameter for binomial family taken to be 1)Null deviance: 638.45  on 559  degrees of freedomResidual deviance: 443.37  on 551  degrees of freedomAIC: 461.37Number of Fisher Scoring iterations: 6</code></pre><blockquote><p>Estimate Std. Error t value Pr(&gt;|t|)<br>估值，标准误差，T值，P值  </p></blockquote><p>其中，我们可以直接通过P值与我们预设的0.05进行比较，来判定对应的解释变量的显著性（我们检验的原假设是，该系数是否显著为0，P&lt;0.05则拒绝原假设，即对应的变量显著不为0），我们可以看到<strong> 截距项Intercept和 信用卡负债、地址、负债率、工龄</strong> 都可以认为是在P为0.05的水平下显著不为0，通过显著性检验</p><h6 id="1-拟合不理想-step-逐步选择"><a href="#1-拟合不理想-step-逐步选择" class="headerlink" title="1. 拟合不理想 step() 逐步选择"></a>1. 拟合不理想 <code>step()</code> 逐步选择</h6><pre><code># 逐步寻优法logit.step &lt;- step(glm, direction = &quot;both&quot;)summary(logit.step)# 前向选择法logit.step &lt;- step(glm, direction = &quot;forward&quot;)summary(logit.step)# 后向选择法logit.step &lt;- step(glm, direction = &quot;backward&quot;)summary(logit.step)</code></pre><hr><blockquote><p>前向选择法：从一元回归开始，逐步增加变量，使指标达到最优<br>后向选择法：从全变量回归方程开始，逐步删去某个变量，使指标值达到最优为止<br>逐步寻优法：综合上述两种方法 </p><p>最后选择  <code>AIC</code> 最小的一组最为最终模型。 </p></blockquote><h6 id="2-监测多重共线性"><a href="#2-监测多重共线性" class="headerlink" title="2. 监测多重共线性"></a>2. 监测多重共线性</h6><pre><code>library(car)vif(glm)</code></pre><ul><li><p>方差膨胀因子（Variance Inflation Factor，VIF）：是指解释变量之间存在多重共线性时的方差与不存在多重共线性时的方差之比。容忍度的倒数，VIF越大，显示共线性越严重。经验判断方法表明：当0&lt;VIF&lt;10，不存在多重共线性；当10≤VIF&lt;100，存在较强的多重共线性；当VIF≥100，存在严重多重共线性。</p><ol><li>完全共线性下参数估计量不存在</li><li>近似共线性下OLS估计量非有效</li><li>参数估计量经济含义不合理</li><li>参数估计量经济含义不合理</li><li>模型的预测功能失效。变大的方差容易使区间预测的“区间”变大，使预测失去意义。</li></ol></li></ul><h3 id="5-预测"><a href="#5-预测" class="headerlink" title="5. 预测"></a>5. 预测</h3><pre><code>library(pROC)pre&lt;-predict(glm,test,type = &quot;response&quot;)</code></pre><ul><li>预测值为概率，则type = response 给出具体的预测概率，而 type = class按规定的阙值给出分类  </li><li>以0.5默认阈值查看 0 ，1 结果  <code>ifelse(pre&gt;0.5,1,0)</code></li></ul><h3 id="6-ROC曲线确定最优阈值"><a href="#6-ROC曲线确定最优阈值" class="headerlink" title="6. ROC曲线确定最优阈值"></a>6. ROC曲线确定最优阈值</h3><pre><code>modelroc&lt;-roc(test$违约,pre)  plot(modelroc,print.auc=TRUE,auc.polygon=TRUE,auc.polygon.col=&quot;skyblue&quot;,print.thres=TRUE, max.auc.polygon=TRUE)</code></pre><p><img src="/2019/05/16/shu-ju-fen-xi/luo-ji-hui-gui/Rplot.png" alt>     </p><h3 id="7-对比检测"><a href="#7-对比检测" class="headerlink" title="7. 对比检测"></a>7. 对比检测</h3><pre><code>result&lt;-ifelse(pre&gt;0.5,1,0)table(test$违约,result)</code></pre><hr><pre><code>   result     0  1  0 91 10  1 17 22</code></pre><p>精确率   </p><ul><li>TP/(TP+FP)</li><li>90/(91+10)=0.90</li></ul><p>召回率</p><ul><li>TP/(TP+FN)</li><li>90/(91+17)=0.83</li></ul><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4><ul><li><p>数据示例    </p><pre><code>          年龄 教育 工龄 地址 收入 负债率 信用卡负债 其他负债 违约  1     41    3   17   12  176    9.3      11.36     5.01    1  2     27    1   10    6   31   17.3       1.36     4.00    0  3     40    1   15   14   55    5.5       0.86     2.17    0  4     41    1   15   14  120    2.9       2.66     0.82    0  5     24    2    2    0   28   17.3       1.79     3.06    1  6     41    2    5    5   25   10.2       0.39     2.16    0  7     39    1   20    9   67   30.6       3.83    16.67    0  8     43    1   12   11   38    3.6       0.13     1.24    0  9     24    1    3    4   19   24.4       1.36     3.28    1  10    36    1    0   13   25   19.7       2.78     2.15    0  11    27    1    0    1   16    1.7       0.18     0.09    0  12    25    1    4    0   23    5.2       0.25     0.94    0  13    52    1   24   14   64   10.0       3.93     2.47    0  14    37    1    6    9   29   16.3       1.72     3.01    0  15    48    1   22   15  100    9.1       3.70     5.40    0  16    36    2    9    6   49    8.6       0.82     3.40    1    </code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析——数据离散化</title>
      <link href="/2019/05/15/shu-ju-fen-xi/shu-ju-chi-san-hua/"/>
      <url>/2019/05/15/shu-ju-fen-xi/shu-ju-chi-san-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="一、如何将数据离散化"><a href="#一、如何将数据离散化" class="headerlink" title="一、如何将数据离散化"></a>一、如何将数据离散化</h2><h3 id="1-常用的离散化方法"><a href="#1-常用的离散化方法" class="headerlink" title="1. 常用的离散化方法"></a>1. 常用的离散化方法</h3><p>常用的离散化方法有等宽法、等频法和(一维)聚类。</p><h4 id="（1）-等宽法"><a href="#（1）-等宽法" class="headerlink" title="（1） 等宽法"></a>（1） 等宽法</h4><p>该法将属性的值域分成具有相同宽度的区间，区间的个数由数据本身的特点决定，或者由用户指定，类似于制作频率分布表。</p><h4 id="（2）-等频法"><a href="#（2）-等频法" class="headerlink" title="（2） 等频法"></a>（2） 等频法</h4><p>该法将相同数量的记录放进每个区间。</p><p>这两种方法简单，易于操作，但都需要人为地规定划分区间的个数。同时，等宽法的缺点在于它对离群点比较敏感，倾向于不均匀地把属性值分布到各个区间，有些区间包含许多数据，而另外一些区间的数据极少，这样会严重损坏建立的决策模型。等频法虽然避免了上述问题的产生，却可能将相同的数据值分到不同的区间以满足每个区间中固定的数据个数。</p><h4 id="（3）（一维）聚类"><a href="#（3）（一维）聚类" class="headerlink" title="（3）（一维）聚类"></a>（3）（一维）聚类</h4><p>（一维）聚类的方法包括两个步骤，首先将连续属性的值用聚类算法（如K-Means算法）进行聚类，然后再将聚类得到的簇进行处理，合并到一个簇的连续属性值并做同一标记。聚类分析的离散化方法也需要用户指定簇的个数，从而决定产生的区间数。</p><hr><pre><code># 读取数据文件，提取标题行data &lt;- read.csv(&#39;./data/discretization_data.csv&#39;, header = TRUE) # 等宽离散化  #ceiling返回对应数字的&#39;天花板&#39;值，就是不小于该数字的最小整数#floor与ceiling相对，返回&#39;地板&#39;值,即不大于该数字的最大值v1 &lt;- ceiling(data[, 1] * 10)head(data)# 等频离散化names(data) &lt;- &#39;f&#39;  # 变量重命名attach(data)seq(0, length(f), length(f) / 6)  # 等频划分为6组v &lt;- sort(f)  # 按大小排序作为离散化依据v2 &lt;- rep(0, 930)  # 定义新变量for (i in 1:930) {  v2[i] &lt;- ifelse (f[i] &lt;= v[155], 1,                   ifelse (f[i] &lt;= v[310], 2,                           ifelse (f[i] &lt;= v[465], 3,                                   ifelse (f[i] &lt;= v[620], 4,                                            ifelse (f[i] &lt;= v[775], 5, 6)))))} detach(data)# 聚类离散化result &lt;- kmeans(data, 6)v3 &lt;- result$cluster# 图示结果plot(data[, 1], v1, xlab = &#39;等宽离散化&#39;)plot(data[, 1], v2, xlab = &#39;等频离散化&#39;)plot(data[, 1], v3, xlab = &#39;聚类离散化&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析——主成分分析</title>
      <link href="/2019/05/13/shu-ju-fen-xi/zhu-cheng-fen-jiang-wei/"/>
      <url>/2019/05/13/shu-ju-fen-xi/zhu-cheng-fen-jiang-wei/</url>
      
        <content type="html"><![CDATA[<h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><h4 id="1-将原始数据标准化"><a href="#1-将原始数据标准化" class="headerlink" title="1. 将原始数据标准化"></a>1. 将原始数据标准化</h4><h4 id="2-建立变量的相关系数矩阵"><a href="#2-建立变量的相关系数矩阵" class="headerlink" title="2. 建立变量的相关系数矩阵"></a>2. 建立变量的相关系数矩阵</h4><ul><li>选择主成分个数</li></ul><h4 id="3-求R的特征根及相应的特征向量"><a href="#3-求R的特征根及相应的特征向量" class="headerlink" title="3. 求R的特征根及相应的特征向量"></a>3. 求R的特征根及相应的特征向量</h4><ul><li>贡献率大于85% 或者  特征根大于1</li></ul><h4 id="4-由累积方差贡献率确定主成分个数"><a href="#4-由累积方差贡献率确定主成分个数" class="headerlink" title="4. 由累积方差贡献率确定主成分个数"></a>4. 由累积方差贡献率确定主成分个数</h4><h4 id="5-对主成分进行分析"><a href="#5-对主成分进行分析" class="headerlink" title="5. 对主成分进行分析"></a>5. 对主成分进行分析</h4><hr><pre><code>library(psych)KMO(cor(inputfile))  #&gt;0.5,可以做主成分分析cortest.bartlett(inputfile)   # H0：变量之间相互独立，要拒绝H0，才有降维的必要#模型分析test&lt;-princomp(inputfile,cor=TRUE)test$sdev#特征根&gt;1，(test$sdev)^2/sum((test$sdev)^2)#方差累积贡献率&gt;85%,确定主成分个数ktest$scores[,1:k]#利用前K个主成分做之后分析的自变量#综合排名计算权重#sum(特征向量*相应特征根的贡献率)/sum(k个主成分贡献率)#计算综合得分：sum（各原始自变量*权重）#得分排名</code></pre><hr><pre><code># 读取数据文件，提取标题行inputfile &lt;- read.csv(&#39;./data/principal_component.csv&#39;, header = FALSE)# 主成分分析PCA &lt;- princomp(inputfile, cor = FALSE)names(PCA)  # 查看输出项(PCA$sdev) ^ 2  # 主成分特征根summary(PCA)  # 主成分贡献率PCA$loadings  # 主成分载荷      PCA$scores  # 主成分得分#确定主成分后选择PCA$scores[,1:k]</code></pre><hr><h5 id="当cor-TRUE是使用相关系数矩阵计算"><a href="#当cor-TRUE是使用相关系数矩阵计算" class="headerlink" title=" 当cor = TRUE是使用相关系数矩阵计算  "></a><strong> 当cor = TRUE是使用相关系数矩阵计算  </strong></h5><h5 id="当cor-FALSE是使用协方差矩阵计算"><a href="#当cor-FALSE是使用协方差矩阵计算" class="headerlink" title=" 当cor = FALSE是使用协方差矩阵计算  "></a><strong> 当cor = FALSE是使用协方差矩阵计算  </strong></h5><h5 id="用相关系数矩阵计算就相当于先标准化，在进行主成分分析"><a href="#用相关系数矩阵计算就相当于先标准化，在进行主成分分析" class="headerlink" title=" 用相关系数矩阵计算就相当于先标准化，在进行主成分分析  "></a><strong> 用相关系数矩阵计算就相当于先标准化，在进行主成分分析  </strong></h5><h5 id="用协方差矩阵计算就是不进行标准化"><a href="#用协方差矩阵计算就是不进行标准化" class="headerlink" title=" 用协方差矩阵计算就是不进行标准化  "></a><strong> 用协方差矩阵计算就是不进行标准化  </strong></h5><ul><li>两种方法根据数据和需求确定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金字塔原理</title>
      <link href="/2019/05/12/luo-ji-si-wei/jin-zi-ta-yuan-li/"/>
      <url>/2019/05/12/luo-ji-si-wei/jin-zi-ta-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="所谓金字塔原则，是一项结构化的思考、沟通和写作的技术。重点关注的是在写作之前的思考过程。"><a href="#所谓金字塔原则，是一项结构化的思考、沟通和写作的技术。重点关注的是在写作之前的思考过程。" class="headerlink" title="所谓金字塔原则，是一项结构化的思考、沟通和写作的技术。重点关注的是在写作之前的思考过程。"></a>所谓金字塔原则，是一项结构化的思考、沟通和写作的技术。重点关注的是在写作之前的思考过程。</h2><h3 id="以下的内容："><a href="#以下的内容：" class="headerlink" title="以下的内容："></a>以下的内容：</h3><ul><li>四项基本原则 <ul><li>结论先行</li><li>以上统下 </li><li>归纳分组 </li><li>逻辑递进</li></ul></li><li>子结构<ul><li>纵向关系<ul><li>横向关系</li></ul></li><li>序言</li></ul></li><li>逻辑顺序<ul><li>时间顺序</li><li>结构顺序</li><li>重要性顺序</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 逻辑思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析——处理缺失值</title>
      <link href="/2019/05/10/shu-ju-fen-xi/chu-li-que-shi-zhi/"/>
      <url>/2019/05/10/shu-ju-fen-xi/chu-li-que-shi-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><p><strong> 数据清洗主要是删除原始数据集中的无关数据、重复数据，平滑噪声数据，筛选掉与挖掘主题无关的数据，处理缺失值、异常值等。</strong></p><h3 id="一、缺失值处理"><a href="#一、缺失值处理" class="headerlink" title="一、缺失值处理"></a>一、缺失值处理</h3><p>从统计上说，缺失的数据可能会产生有偏估计，从而使样本数据不能很好地代表总体，而现实中绝大部分数据都包含缺失值，因此如何处理缺失值很重要。<br>一般来说，缺失值的处理包括两个步骤，即缺失数据的识别和缺失值处理。在R语言中缺失值通常以NA表示，可以使用函数<code>is.na()</code>判断缺失值是否存在，另外数<code>complete.cases()</code>可识别样本数据是否完整从而判断缺失情况。在对是否存在缺失值进行判断之后需要进行缺失值处理，常用的方法有删除法、替换法、插补法等。</p><h4 id="1-删除法"><a href="#1-删除法" class="headerlink" title="1. 删除法"></a>1. 删除法</h4><p>删除法是最简单的缺失值处理方法，根据数据处理的不同角度可分为删除观测样本、删除变量两种。删除观测样本又称行删除法，在R中可通过<code>na.omit()</code>函数移除所有含有缺失数据的行，这属于以减少样本量来换取信息完整性的方法，适用于缺失值所占比例较小的情况；删除变量适用于变量有较大缺失且对究目标影响不大的情况，意味着要删除整个变量，这在R中可通过<code>data[ ,-p]</code>来实现，其中data表示目标数据集，p表示缺失变量所在的列。  </p><h4 id="2-替换法"><a href="#2-替换法" class="headerlink" title="2. 替换法"></a>2. 替换法</h4><p>变量按属性可分为数值型和非数值型，二者的处理办法不同：如果缺失值所在变量为数值型的，一般用该变量在其他所有对象的取值的均值来替换变量的缺失值；如果为非数值型变量，则使用该变量其他全部有效观测值的中位数或者众数进行替换。</p><h4 id="3-插补法"><a href="#3-插补法" class="headerlink" title="3. 插补法"></a>3. 插补法</h4><p>删除法虽然简单易行，但会存在信息浪费的问题且数据结构会发生变动，以致最后得到有偏的统计结果，替换法也有类似问题。在面对缺失值问题，常用的插补法有回归插补、多重插补等。回归插补法利用回归模型，将需要插值补缺的变量作为因变量，其他相关变量作为自变量，通过回归函数lm()预测出因变量的值来对缺失变量进行补缺；多重插补法的原理是从一个包含缺失值的数据集中生成一组完整的数据，如此进行多次，从而产生缺失值的一个随机样本，R中的函数包可以用来进行多重插补。</p><hr><pre><code># 读取数据文件，提取标题行&gt;inputfile &lt;- read.csv(&#39;./data/catering_sale.csv&#39;, header = TRUE) # 变换变量名&gt;inputfile &lt;- data.frame(sales = inputfile$&#39;销量&#39;, date = inputfile$&#39;日期&#39;)  &gt;head(inputfile)# 数据截取&gt;inputfile &lt;- inputfile[5:16, ]# 缺失数据的识别&gt;is.na(inputfile)  # 判断是否存在缺失  &gt;n &lt;- sum(is.na(inputfile))  # 输出缺失值个数# 异常值识别&gt;par(mfrow = c(1, 2))  # 将绘图窗口划为1行两列，同时显示两图   &gt;dotchart(inputfile$sales)  # 绘制单变量散点图  &gt;boxplot(inputfile$sales, horizontal = TRUE)  # 绘制水平箱形图 # 异常数据处理&gt;inputfile$sales[5] = NA  # 将异常值处理成缺失值  &gt;fix(inputfile)  # 表格形式呈现数据# 缺失值的处理&gt; inputfile$date &lt;- as.numeric(inputfile$date)  # 将日期转换成数值型变量  &gt; sub &lt;- which(is.na(inputfile$sales))  # 识别缺失值所在行数  &gt; inputfile1 &lt;- inputfile[-sub, ]  # 将数据集分成完整数据和缺失数据两部分  &gt; inputfile2 &lt;- inputfile[sub, ]  # 行删除法处理缺失，结果转存&gt; result1 &lt;- inputfile1 # 均值替换法处理缺失，结果转存&gt; avg_sales &lt;- mean(inputfile1$sales)  # 求变量未缺失部分的均值  &gt; inputfile2$sales &lt;- rep(avg_sales,n)  # 用均值替换缺失  &gt; result2 &lt;- rbind(inputfile1, inputfile2)  # 并入完成插补的数据   # 回归插补法处理缺失，结果转存&gt; model &lt;- lm(sales ~ date, data = inputfile1)  # 回归模型拟合   &gt; inputfile2$sales &lt;- predict(model, inputfile2)  # 模型预测 &gt; result3 &lt;- rbind(inputfile1, inputfile2) # 多重插补法处理缺失，结果转存&gt;library(lattice)  # 调入函数包  &gt;library(MASS)   &gt;library(nnet)  &gt;library(mice)  # 前三个包是mice的基础                  &gt;imp &lt;- mice(inputfile, m = 4)  # 4重插补，即生成4个无缺失数据集  &gt;fit &lt;- with(imp,lm(sales ~ date, data = inputfile))  # 选择插补模型  &gt;pooled &lt;- pool(fit)  &gt;summary(pooled)  &gt;result4 &lt;- complete(imp, action = 3)  # 选择第三个插补数据集作为结果  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准确率与召回率</title>
      <link href="/2019/05/08/tong-ji-xue/tong-ji-xue/"/>
      <url>/2019/05/08/tong-ji-xue/tong-ji-xue/</url>
      
        <content type="html"><![CDATA[<p>1、两个最常见的衡量指标是“准确率（precision）”（你给出的结果有多少是正确的）和“召回率（recall）”（正确的结果有多少被你给出了）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何写好一份数据分析报告</title>
      <link href="/2019/05/06/shu-ju-fen-xi/shu-ju-fen-xi-bao-gao/"/>
      <url>/2019/05/06/shu-ju-fen-xi/shu-ju-fen-xi-bao-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="如何写好一份数据分析报告"><a href="#如何写好一份数据分析报告" class="headerlink" title="如何写好一份数据分析报告"></a>如何写好一份数据分析报告</h1><p><strong>一份好的数据分析报告要有以下要点：</strong></p><p><strong>1. 框架</strong></p><p>万丈高楼平地起，一个好的框架是这份报告的前提条件。</p><p>好的分析肯定要有基础有层次，基础坚实并且层次分明才会让读者一目了然；架构清晰、主次分明才能让别人容易读懂，这样才会有读者愿意去读下去。</p><p><strong>2. 结论</strong></p><p>虽然在平时，对一件事情盖棺定论不是一种好的行为，但数据分析恰恰就是通过对数据的理性分析产出结论。所以，数据每一个数据分析都要有结论，而且结论一定要明确，不能模糊，顾左右而言他，那样就会失去数据分析的意义。</p><p><strong>3. 简而精</strong></p><p>上面提到每一个数据分析都要有结论，如果可以的话一个分析一个结论就足够了，不要太多要精，大部分时候数据分析师用来发现问题的，发现了一个重大问题就达到目的了，不要事事求多。要坐到宁要仙桃一扣，不要烂杏一筐，精简的结论也容易让读者接受，降低读者心里门槛。（结论繁多，没人能读下去，再多的结论也是0）</p><p><strong>4. 实事求是</strong></p><p>分析结论一定要基于紧密的数据分析推到过程，不要有猜测性的结论，过于主观的东西没有说服力，不是给读者看的，而只是满足自己的臆想。就请不要拿来误导广大吃瓜群众了。</p><p><strong>5. 可读性</strong></p><p>好的分析要有很强的可读性，人与人之间的阅读习惯和细微模式不尽相同，写东西是总是不经意间按照自己的思维逻辑来写。你自己读起来很明白，是因为整个分析过程都是你做的，但是读者不知道啊，要知道你辛辛苦苦几周做出来的东西，往往其他人只是用10分钟或是更短的事件来阅读，所以你要考虑你的报告阅读者是谁？他们最关心什么？</p><p><strong>6. 图表化</strong></p><p>将数据分析报告图表化，用图表代替数字的堆砌会让人更佳形象直观的看清问题和结论，但要注意，图表也不能过多，让读者无所适从。</p><p><strong>7. 逻辑性</strong></p><p>好的分析报告要有逻辑性，通常逻辑要遵守：①数据是怎么来的；②发现了什么问题；③总结问题发生的原因；④如何解决这种问题。这样一个简单明了强逻辑关系的分析报告就能让绝大多数人接受。</p><p><strong>8. 了解业务</strong></p><p>好的分析报告都是出自分析人对所分析的业务了解的前提下，做数据分析的人一定要很了解你所分析的事情，如果你连要分析的对象基本特征都不了解，分析出来的结论也都只是空中楼阁，让人无法信服。</p><p><strong>9. 可靠地底层数据</strong></p><p>一定要有可靠的底层数据，整理和收集数据，是数据分析报告中最耗费和占用时间的一步，包括规划定义、数据采集、文本语义分析、大数据存储和查询等等，一定要从一开始就明确的知道自己要分析什么，才能采集和挖掘好匹配的数据，在正确的数据上进行分析，从而得出正确的结论， 否则一切都将变成为了误导别人的努力 。</p><p><strong>10. 解决和建议方案</strong></p><p>好的分析报告一定要有解决方案和建议方案，你既然很努力地去了解，并在了解的基础上做了深入的分析，那么这个过程就决定了你可能比别人都更清楚 第发现了问题及问题产生的原因，那么在这个基础之上基于你的知识和了解，做出的建议和结论想必也会更有意义，而且受众也肯定不希望你只是个会发现问题 的人，也请你直言不讳的指出解决办法吧。</p><p><strong>11. 不要害怕</strong></p><p>不要因为你的报告分析出来的“不良结论”就担惊受怕，想办法回避。相反你应该直击通点，阐明结论。分析就是为了发现问题，这是你的报告价值所在，你发的报告不是用来赞美、用来歌颂的，也不是用来粉饰缺点的工具的。发现问题，在问题产生严重后果前解决它，这就是数据报告的价值所在。</p><p><strong>12. 通俗易懂</strong></p><p>不要创造太多难懂的词汇，如果一个读者在看你的报告时，要花费十几分钟去查那些名词是什么，那你的报告价值又在哪里呢，还不如你站在大家面前去说呢，如果确实专业性很强，不妨写一个简单易行的“名词解释”</p><p><strong>13. 感恩</strong></p><p>最后，不要忘记去感谢那些为你的数据分析报告付出过努力和贡献的人，没有他们的辛劳和汗水，就没有你的数据报告。</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学基础（四）</title>
      <link href="/2019/05/04/tong-ji-xue/tong-ji-xue-4/"/>
      <url>/2019/05/04/tong-ji-xue/tong-ji-xue-4/</url>
      
        <content type="html"><![CDATA[<p>统计学基础（四）</p><h1 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1.线性回归"></a>1.线性回归</h1><h2 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h2><p>二变量数据：对于每一个观察结果，二变量数据给出两个变量数值</p><p>常用表示图形：散点图（散布图），散点图的作用在于能体现数据的实际模式，通过散点图，你可以清晰地看出两个变量的关系</p><p>正线性相关：x增长，y也涨</p><p>负线性相关：x增长，y下降</p><p>不相关：x和y数值呈现一种随机模式</p><p>两个变量之间存在相关关系（数学关系），并不一定意味着一个变量会影响另一个变量，也不意味着二者存在实际关系</p><p>最佳拟合线：能最好的接近所有数据点的线（最佳预测）</p><p>如果确定最佳拟合线：表达式为<img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/1.gif" alt><br>且使得y的实际观察值与每个x相对应的y的估计值的差距最小的线</p><p>如何确定差距最小：利用误差平方和<img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/2.gif" alt>  ，和方差的计算方法很相近</p><h2 id="1-2-拟合线计算步骤"><a href="#1-2-拟合线计算步骤" class="headerlink" title="1.2 拟合线计算步骤"></a>1.2 拟合线计算步骤</h2><ul><li>求出 $\overline{x}$和 $\overline{y}$</li><li>计算y = a+bx中的斜率（陡度） b ，即 b 为最佳拟合线的斜率，公式为：<img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/3.gif" alt></li><li>最佳拟合线最好穿过x和y的均值 $\overline{x}$ ，$\overline{y}$，带入计算计算 a = $\overline{y}$ - b$\overline{x}$</li><li>得到最佳拟合线</li></ul><blockquote><p>最小二乘法</p><p>一种数学方法，可以用一条最佳拟合线将一组二变量数据拟合</p><p>通过将公式 y = a + bx 的一条直线与一组数值相拟合，使得误差平方和最小——即使得实际数值与这些数值的估计值之间的差值最小。</p><p>其中，直线 y = a + bx 被称为<strong>回归线</strong></p></blockquote><h2 id="1-3-判断准确性"><a href="#1-3-判断准确性" class="headerlink" title="1.3 判断准确性"></a>1.3 判断准确性</h2><p>利用回归线的相关性强度——相关系数</p><p>相关系数介于 -1 和 1 之间，描述了各个数据点与直线的偏离程度，度量回归线与数据的拟合度，用字母 r 表示</p><ul><li>r=-1，数据为完全负线性相关；</li><li>r=1，完全正线性相关；</li><li>r=0，不存在相关性</li></ul><blockquote><p>计算相关系数r</p><p>计算公式：<img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/4.gif" alt> <img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/5.gif" alt> <img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/6.gif" alt> </p><p>其中 $s_x$ 是样本中的x值的标准差，$s_y$</p></blockquote><h1 id="2-方差分析（Analysis-of-Variance，简称ANOVA）"><a href="#2-方差分析（Analysis-of-Variance，简称ANOVA）" class="headerlink" title="2. 方差分析（Analysis of Variance，简称ANOVA）"></a>2. 方差分析<strong>（Analysis of Variance，简称ANOVA）</strong></h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>一个假设检验过程，用于评估两个或者多个处理（总体）的平均数的差异，也可以说，方差分析和t检验只是做相同工作的两种不同的方法。</p><h2 id="2-2-方差分析举例分析"><a href="#2-2-方差分析举例分析" class="headerlink" title="2.2 方差分析举例分析"></a>2.2 方差分析举例分析</h2><p>某饮料生产企业研制出一种新型饮料。饮料的颜色共有四种，分别为橘黄色、粉色、绿色和无色透明。这四种饮料的营养含量、味道、价格、包装等可能影响销售量的因素全部相同，先从地理位置相似、经营规模相仿的五家超级市场上收集了前一期该种饮料的销售量情况，见表</p><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/7.png" alt></p><h3 id="2-2-1-方差分析术语"><a href="#2-2-1-方差分析术语" class="headerlink" title="2.2.1 方差分析术语"></a>2.2.1 方差分析术语</h3><ul><li>因素：因素是一个独立的变量，也就是方差分析研究的对象，也称为因子。如：例1中，我们要分析饮料的颜色对饮料的销售量是否有影响，在这里，“饮料的颜色”是所要检验的对象，它就是一个因素。在有的书中把因素称为“因子”。</li><li>水平因素中的内容称为水平，它是因素的具体表现。如：例1中“饮料的颜色”这一因素中的水平有四个，即饮料的四种不同颜色：无色、粉色、桔黄色、绿色；它们是“饮料的颜色”这一因素的四种具体表现。 因素的每一个水平可以看作是一个总体，比如：无色、粉色、桔黄色、绿色饮料可以看作是四个总体。</li><li>控制变量在方差分析中，能够人为控制的影响因素称为控制因素，或控制变量；如：例1中，“饮料的颜色”对于饮料的销售量而言，是能够人为控制的影响因素，称为控制变量。</li><li>随机变量在方差分析中，人为很难控制的影响因素称为随机因素，或随机变量；如：例1中，“人们对不同颜色的偏爱”对于饮料的销售量而言，是人为很难控制的影响因素，称为随机变量。</li><li>观察变量与观察值 在方差分析中，受控制因素和随机因素影响的事物，称为观察变量。在每个水平下得到的样本数据称为观察值。如：例1中，销售量是观察变量，在每个饮料颜色下得到的样本数据（即表10－1中的数据）就是观察值。</li></ul><h3 id="2-2-2-方差分析的原理"><a href="#2-2-2-方差分析的原理" class="headerlink" title="2.2.2 方差分析的原理"></a>2.2.2 方差分析的原理</h3><p>从方差分析的目的来看，是要检验各个水平的均值μ1、μ2、…、μm是否相等（m为水平个数），而实现这个目的的手段是通过方差的比较（即考察各观察数据的差异）。 在变量的观察值之间存在着差异。差异的产生来自于两个方面。</p><p>一个方面是由因素中的不同水平造成的，称之为系统性差异（或系统性误差）。如：饮料的不同颜色带来不同的销售量。</p><p>另一个方面是由于抽选样本的随机性而产生的差异，称之为随机性差异（或随机性误差）。如：相同颜色的饮料在不同的商场销售量也不同。 两个方面产生的差异可以用两个方差来计量。</p><p>一个叫<strong>组间方差</strong>，即水平之间的方差，是衡量不同总体下各样本之间差异的方差。在组间方差里，既包括系统性误差，也包括随机性误差。如：在例1中，不同颜色的饮料在不同地点（超市）产品销售量之间的差异既有系统性误差（即由于人们对不同颜色的偏爱造成的差异），也有随机性误差（即由于抽样的随机性造成的差异）。不同颜色的饮料在不同地点（超市）产品销售量之间的方差即为组间方差。</p><p>另一个叫<strong>组内方差</strong>，即水平内部的方差，是衡量同一个总体下样本数据的方差。在组内方差里仅包括随机性差异。如：在例1中，可以把同一个颜色的饮料在不同地点（超市）产品销售量之间的差异看成是随机因素的影响，同一个颜色的饮料在不同地点（超市）产品销售量之间的方差即为组内方差。</p><p>如果不同的水平对结果没有影响，如: 饮料的不同颜色对销售量无影响，那么在水平之间的方差中，就仅仅有随机因素影响的差异，而没有系统性因素影响的差异。这样一来，组间方差与组内方差就应该非常接近，两个方差的比值就会接近于1；反之，如果饮料的不同颜色对销售量有影响，在组间方差中就不仅包括了随机性误差，也包括了系统性误差，这时，组间方差就会大于组内方差，两个方差的比值就会大于1。当这个比值大到某种程度时，我们就可以作出判断，说不同水平之间存在着显著性差异。一次，方差分析就是通过不同方差的比较，作出接受原假设或拒绝原假设的判断。如：例子中，判断饮料的不同颜色对销售量是否有显著性影响的问题，实际上也就是检验销售量的差异主要是由于什么原因所引起的。如果这种差异主要是系统性误差，我们就说饮料的不同颜色对销售量有显著性影响。</p><h3 id="2-2-3-方差分析思路"><a href="#2-2-3-方差分析思路" class="headerlink" title="2.2.3 方差分析思路"></a>2.2.3 方差分析思路</h3><p>从表中看到，20个数据各不相同，其原因可能有两个方面：   </p><ul><li>一是销售地点不同的影响。即使是相同颜色的饮料，在不同超市的销售量也是不同的。但是，由于这五个超市地理位置相似、经营规模相仿，因此，可以把不同地点产品销售量的差异看成是随机因素的影响。</li><li>二是饮料颜色不同的影响。即使在同一个超市里，不同颜色的饮料的销售量也是不同的。哪怕它们的营养成分、味道、价格、包装等方面的因素都相同，但销售量也不相同。这种不同，有可能是由于抽样的随机性造成的，也有可能是由于人们对不同颜色的偏爱造成的。</li></ul><p>于是，上述问题就归结为检验饮料颜色对销售量是否有影响的问题。我们可以令μ1、μ2、μ3、μ4分别为四种颜色饮料的平均销售量，检验它们是否相等。如果检验结果显示μ1、μ2、μ3、μ4不相等，则意味着不同颜色的饮料来自于不同的总体，表明饮料颜色对销售量有影响；反之，如果检验结果显示μ1、μ2、μ3、μ4之间不存在显著性差异，则意味着不同颜色的饮料来自于相同的总体，可认为饮料颜色对销售量没有影响。</p><h3 id="2-2-4-计算分析"><a href="#2-2-4-计算分析" class="headerlink" title="2.2.4 计算分析"></a>2.2.4 计算分析</h3><ul><li>建立假设</li></ul><p>原假设： $H_0$ ：$μ_1$ = $μ_2$ = $μ_3$ = $μ_4$ ；即假设颜色对销售量没有影响。</p><p>备则假设： $H_1$ ：$μ_1$ 、 $μ_2$ 、 $μ_3$ 、 $μ_4$ 不全相等，即假设四个配方颜色对销售量有影响。</p><ul><li>计算水平均值</li></ul><p>无色饮料销售量均值＝136.6÷5＝27.32箱</p><p>粉色饮料销售量均值＝147.8÷5＝29.56箱</p><p>桔黄色饮料销售量均值＝132.2÷5＝26.44箱</p><p>绿色饮料销售量均值＝157.3÷5＝31.46箱</p><ul><li>计算全部观察值的总均值</li></ul><p>各种颜色饮料销售量总的样本平均数＝(136.6+147.8+132.2+157.3)÷20＝28.695箱</p><ul><li>计算离差平方和</li></ul><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/8.png" alt></p><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/9.png" alt></p><ul><li>构造统计量并计算检验统计量的样本值  </li></ul><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/10.png" alt></p><ul><li>确定检验规则、列出方差分析表、做出统计决策 P-值规则</li></ul><p>根据算得的检验统计量的样本值（F值）算出P-值＝0.000466。由于P-值＝0.000466＜显著水平标准=0.05,所以拒绝H0，接受备择假设H1,即通过检验知，μj不全相等，说明饮料的颜色对销售量有显著影响。</p><h3 id="2-2-5-结论"><a href="#2-2-5-结论" class="headerlink" title="2.2.5 结论"></a>2.2.5 结论</h3><p><strong>临界值规则</strong>：根据给定的显著水平a＝0.05，查表得临界值为3.24。因为F＝10.486＞3.24，检验统计量的样本值落入拒绝域，所以拒绝H0,接受备择假设H1,即通过检验知，μj不全相等，说明饮料的颜色对销售量有显著影响。</p><p><strong>p值大于显著水平，支持原假设，F值大于临界值（由显著水平得到），拒绝原假设。</strong></p><h1 id="3-卡方分布（-χ-2-）"><a href="#3-卡方分布（-χ-2-）" class="headerlink" title="3. 卡方分布（$χ^2$）"></a>3. 卡方分布（$χ^2$）</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>$χ^2$分布，这种分布通过一个检验统计量来比较期望结果和实际结果之间的差别，然后得出观察频数极值的发生概率。</p><h2 id="3-2-χ-2-分布的两个主要用途"><a href="#3-2-χ-2-分布的两个主要用途" class="headerlink" title="3.2 $χ^2$分布的两个主要用途"></a>3.2 $χ^2$分布的两个主要用途</h2><ul><li>检验拟合优度：也就是可以检验一组给定的数据与指定分布的吻合程度。</li><li>检验两个变量独立性：通过这个方法可以检查变量之间是否存在着某种关联</li></ul><h2 id="3-3-计算步骤"><a href="#3-3-计算步骤" class="headerlink" title="3.3 计算步骤"></a>3.3 计算步骤</h2><h3 id="3-3-1-确定要进行检验的假设及备选假设"><a href="#3-3-1-确定要进行检验的假设及备选假设" class="headerlink" title="3.3.1 确定要进行检验的假设及备选假设"></a>3.3.1 确定要进行检验的假设及备选假设</h3><h3 id="3-3-2-求出期望频数和自由度"><a href="#3-3-2-求出期望频数和自由度" class="headerlink" title="3.3.2 求出期望频数和自由度"></a>3.3.2 求出期望频数和自由度</h3><p>$χ^2$分布用到一个参数——希腊字母 ν ，读作“纽”</p><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/11.png" alt></p><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/12.png" alt></p><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/13.png" alt></p><p><strong> ν 表示自由度</strong> ν 为自由度数据，及用于计算检验统计量（$χ^2$）的独立变量的数目，或可以说是独立信息段的数目。</p><p>自由度数目等于我们要计算的期望频数的数目——计算式要考虑我们所受到的各种限制，</p><p> ν = 我们所计算过信息的数目（组数） - 限制（期望频数综合 = 观察频数总和）数</p><p>几种常见概率分布的自由度：</p><p><img src="/2019/05/04/tong-ji-xue/tong-ji-xue-4/14.png" alt></p><h3 id="3-3-3-确定用于决策拒绝域"><a href="#3-3-3-确定用于决策拒绝域" class="headerlink" title="3.3.3 确定用于决策拒绝域"></a>3.3.3 确定用于决策拒绝域</h3><h3 id="3-3-4-计算检验统计量-χ-2"><a href="#3-3-4-计算检验统计量-χ-2" class="headerlink" title="3.3.4 计算检验统计量$χ^2$"></a>3.3.4 计算检验统计量$χ^2$</h3><p>用观察频数和期望频数计算下列统计量。</p><p>$χ^2$ =$\sum$ $\frac{(O-E)^2}{E}$</p><p>其中O代表观察频数，E代表期望频数。</p><p>对于概率分布的每一个概率，取期望频数和实际频数的差，求差的平方数，再除以期望频数，然后将所有结果相加</p><h3 id="3-3-5-查看检验统计量是否位于拒绝域以内"><a href="#3-3-5-查看检验统计量是否位于拒绝域以内" class="headerlink" title="3.3.5 查看检验统计量是否位于拒绝域以内"></a>3.3.5 查看检验统计量是否位于拒绝域以内</h3><p>如用过显著性水平 α 进行检验，则可以写作</p><p>$χ^2_α$(ν)  </p><p>$χ^2$分布的拒绝域，可以通过使用$χ^2$概率表来得到</p><h3 id="3-3-6-做出决策"><a href="#3-3-6-做出决策" class="headerlink" title="3.3.6 做出决策"></a>3.3.6 做出决策</h3><hr><h1 id="4-因果性和相关性"><a href="#4-因果性和相关性" class="headerlink" title="4.因果性和相关性"></a>4.因果性和相关性</h1><ul><li>存在因果关系则一定相关，但存在相关关系并不一定因果</li></ul><h1 id="5-演绎推理"><a href="#5-演绎推理" class="headerlink" title="5.演绎推理"></a>5.演绎推理</h1><ul><li>归纳推理：用已有信息进行趋势外推，趋势不一定继续；例如根据历史数据推测人口模式</li><li>演绎推理：从事实出发演绎得到另一个事实，但知道事实肯定正确；例如解方程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学基础（三）</title>
      <link href="/2019/05/03/tong-ji-xue/tong-ji-xue-3/"/>
      <url>/2019/05/03/tong-ji-xue/tong-ji-xue-3/</url>
      
        <content type="html"><![CDATA[<h1 id="统计学基础（三）"><a href="#统计学基础（三）" class="headerlink" title="统计学基础（三）"></a>统计学基础（三）</h1><h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><p><strong>Table of Contents</strong></p><p>定义：在日常生活中我们常常需要做出决策，而我们在做决策时一定要预估事件可能发生的结果及概率。假设检验就是一种判断某个事件发生的可能性时使用的科学方法，它常常是先提出一个假设，即原假设；与之对应的是备择假设。假设检验的作用就是判断原假设成立的概率有多大。</p><h2 id="1-假设检验的步骤："><a href="#1-假设检验的步骤：" class="headerlink" title="1. 假设检验的步骤："></a>1. 假设检验的步骤：</h2><ol><li><p>确定要进行检验的假设</p></li><li><p>确定原假设 H0 ，除非有充分证据进行反驳，否则就接受原假设的断言</p></li><li><p>确定备选假设 H1 ，即与原假设对立的断言</p></li></ol><blockquote><p>进行假设检验时，假定原假设为真；如果有足够的证据反驳原假设，则拒绝原假设，接受备选假设</p></blockquote><h2 id="2-选择检验统计量"><a href="#2-选择检验统计量" class="headerlink" title="2. 选择检验统计量"></a>2. 选择检验统计量</h2><p>（用于对假设进行检验的统计量，是与该检验关系最为密切的统计量）</p><p> 选择标准：根据原假设 <strong>H0</strong> 来选择检验统计量</p><h2 id="3-确定用于做决策的拒绝域"><a href="#3-确定用于做决策的拒绝域" class="headerlink" title="3. 确定用于做决策的拒绝域"></a>3. 确定用于做决策的拒绝域</h2><p><strong>拒绝域定义</strong>：假设检验的拒绝域是一组数值，这组数值给出反驳原假设的最极端证据。即我妈们指定一个拒绝域，就可以合理的拒绝原假设</p><p>我们把拒绝域的分界点称为“c”——临界值。</p><p>为了求出拒绝域，需要先定<strong>显著性水平</strong>！（一旦确定了显著性水平，就无法改变）</p><p><strong>显著性水平（以百分数表示）</strong>：度量的是一种愿望，即希望在样本结果的不可能程度达到多大时，就拒绝原假设 <strong>H0</strong></p><p>显著性水平通常用希腊字母 <strong>α</strong> 表示。α 越小，为了拒绝<strong>H0</strong>，样本需要达到的不可能程度越高。</p><p><strong>1、该使用多高的显著性水平？</strong></p><p><strong>P ( x &lt; c ) &lt; α ( α = 0.05 )</strong></p><p><strong>2、单尾检验</strong></p><p>检测的拒绝域落在可能的数据集的一侧，选择检验水平，以 <strong>α</strong> 表示，然后确保拒绝域以相应的概率反映这个水平。尾部可以是可能数据集的左侧或者右侧，具体用哪一侧取决于备选假设 <strong>H1</strong> 。如果备选假设包含一个“&lt;”符号，则使用左尾，此时拒绝域位于数据的低端；如果备选假设包含一个“&gt;”符号，则使用右尾，此时拒绝域位于数据的高端</p><p><strong>3、双尾检验</strong></p><p>拒绝域一分为二位于数据集的两侧，选择检验水平α，然后将拒绝域一分为二，并确保整个拒绝域以相应的概率反应这个检验水平。两侧各占α，因为总和为α。</p><p>判断是否需要双尾检验的设方法是：查看备选假<strong>H1</strong>，如果<strong>H1</strong>包含一个不等号“ <strong>≠</strong> ”，则需要双尾检验。</p><h2 id="4-求出检验统计量的P值"><a href="#4-求出检验统计量的P值" class="headerlink" title="4. 求出检验统计量的P值"></a>4. 求出检验统计量的P值</h2><p>（在假定段艳伟真的情况下，我们的试验结果的可信程度）</p><p>P值定义：某个小于或等于拒绝域方向上的一个样本数值的概率，具体求法是利用样本进行计算，然后判定样本结果是否落在假设检验的拒绝域以内，也就是说，<strong>我们通过P值确定是否该拒绝原假设</strong>。</p><blockquote><p>P值怎么求：P值即为取得样本中的跟踪结果或去的拒绝域方向上的某些更为极端的结果的概率</p></blockquote><h2 id="5-查看样本结果是否位于拒绝域内"><a href="#5-查看样本结果是否位于拒绝域内" class="headerlink" title="5. 查看样本结果是否位于拒绝域内"></a>5. 查看样本结果是否位于拒绝域内</h2><p>（了解试验结果是否位于确定性限值范围内）</p><p>通过求出的P值来检查样本结果是否落在拒绝域内。</p><h2 id="6-做出决策"><a href="#6-做出决策" class="headerlink" title="6. 做出决策"></a>6. 做出决策</h2><hr><h1 id="两类错误"><a href="#两类错误" class="headerlink" title="两类错误"></a>两类错误</h1><p>我们通过以上的步骤，可能正确地接受或者拒绝原假设，但即使再考虑了证据的情况下，仍然有可能犯错误。你可能会拒绝一个正确的原假设，也可能接受一个实质上错误的原假设。统计学家为以上类型的错误给出了专用名称</p><h2 id="1-第一类错误：错误地拒绝真原假设"><a href="#1-第一类错误：错误地拒绝真原假设" class="headerlink" title="1. 第一类错误：错误地拒绝真原假设"></a>1. 第一类错误：错误地拒绝真原假设</h2><p>P(第一类错误) = α，其中α为检验的显著性水平</p><h2 id="2-第二类错误：错误地接受假原假设"><a href="#2-第二类错误：错误地接受假原假设" class="headerlink" title="2. 第二类错误：错误地接受假原假设"></a>2. 第二类错误：错误地接受假原假设</h2><p>P(第二类错误) = β  </p><p><strong>求β步骤</strong></p><blockquote><p>1、检查是否拥有<strong>H1</strong>的特定数值（没有这个数值无法计算第二类错误概率）。<br>2、求检验拒绝域以外的数值范围（如果检验统计量已经标准化，则该数值范围要进行逆标准化）<br>3、假定<strong>H1</strong>为真，求得到这些数值的概率</p></blockquote><p><strong>假设检验决策</strong><br>    实际情况</p><table><thead><tr><th></th><th>接受H0</th><th>拒绝H0</th></tr></thead><tbody><tr><td>H0真</td><td></td><td>第一类错误</td></tr><tr><td>H0假</td><td>第二类错误</td><td>&nbsp;</td></tr></tbody></table><h2 id="3-功效"><a href="#3-功效" class="headerlink" title="3. 功效"></a>3. 功效</h2><p>定义：在H0为假的情况下拒绝!H0的概率，也就是说，这是我们做出正确决策而拒绝!H0的概率</p><p>功效 = 1 - β</p><p>其中β等于发生第二类错误的概率</p><hr><h1 id="Z-统计量-vs-T-统计量"><a href="#Z-统计量-vs-T-统计量" class="headerlink" title="Z-统计量 vs T-统计量"></a>Z-统计量 vs T-统计量</h1><ul><li>当样本数量足够大(z&gt;30)时，样本抽样均值分布服从正态分布，此时可使用Z分布表</li><li>当样本数量很小(z&lt;30)时，样本抽样均值分布服从t分布，此时应使用t分布表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学基础（二）</title>
      <link href="/2019/05/02/tong-ji-xue/tong-ji-xue-2/"/>
      <url>/2019/05/02/tong-ji-xue/tong-ji-xue-2/</url>
      
        <content type="html"><![CDATA[<h1 id="统计学基本知识（二）"><a href="#统计学基本知识（二）" class="headerlink" title="统计学基本知识（二）"></a>统计学基本知识（二）</h1><p>此文目的旨在对统计学知识进行回顾</p><h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><ul><li>任何具有良好定义的具有均值与标准差的分布，随机取出 m 组样本量为 n 的样本。只要样本量 n 足够大，这些样本的均值就收敛于正态分布。</li></ul><h2 id="样本均值的抽样分布"><a href="#样本均值的抽样分布" class="headerlink" title="样本均值的抽样分布"></a>样本均值的抽样分布</h2><ul><li>即原分布的抽样所得均值形成的分布</li></ul><h3 id="偏度"><a href="#偏度" class="headerlink" title="偏度"></a>偏度</h3><ul><li>正偏态分布：右侧尾部较长</li><li>负偏态分布：左侧尾部较长</li></ul><h3 id="峰度"><a href="#峰度" class="headerlink" title="峰度"></a>峰度</h3><ul><li>正峰态：曲线更陡峭，尾部较长</li><li>负峰态：曲线更平缓，尾部较短</li></ul><p><strong>抽样样本容量越大，抽样分布均值形成的分布就越趋近于正态分布，标准差越小，曲线越紧凑</strong></p><h2 id="均值标准误差"><a href="#均值标准误差" class="headerlink" title="均值标准误差"></a>均值标准误差</h2><ul><li>抽样分布均值的分布标准差</li><li><strong>公式</strong>：<img src="/2019/05/02/tong-ji-xue/tong-ji-xue-2/1.jpg" alt>   </li></ul><p><strong>上面所提到的基础信息可以帮助我们在分布未知的情形下，利用中心极限定理来计算概率。具体步骤为：</strong></p><ul><li>根据中心极限定理可知，在样本量足够大的前提下，<strong>原分布总体均值可近似等同于抽样分布总体均值</strong>，并通过样本量与总体标准差计算出均值标准误差</li><li>计算 Z-分数，并通过查表确认偏离中心的距离，从而确定概率。<strong>注意</strong>分数表中特定的Z-分数值对应的概率为左开右闭区间</li></ul><h2 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h2><ul><li>又名 0-1 分布，是一个离散型分布。</li><li>统计量：<ul><li>μ = p</li><li>σ^2 = p ( 1-p )</li></ul></li></ul><h2 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h2><ul><li>即以概率 p 成立的误差区间。与之相对应的是置信水平，常常取值0.05。</li><li>从均值标准误差的公式可以看出，抽样样本量越大，对应的标准差越小。则在同样的置信水平下，误差区间就越小，得到的估计值就越精确。例如在前面的学习当中，我们可以得知在样本均值落在两个标准差区间内的概率约为95%，此时若提高样本量，则标准差变小，估计值所在的范围也就越小，自然就越精确。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在计算概率时，要理清样本均值、总体均值、抽样分布均值三者的关系。<ul><li>样本均值是从总体中抽样所得样本的均值，样本的标准差也只是对总体的一个估计值，不完全相等</li><li>在样本量足够大的前提下，抽样分布均值趋近于总体均值</li><li>同样的置信水平下，可以通过增加样本量来提高准确度</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学基础（一）</title>
      <link href="/2019/05/01/tong-ji-xue/tong-ji-xue-1/"/>
      <url>/2019/05/01/tong-ji-xue/tong-ji-xue-1/</url>
      
        <content type="html"><![CDATA[<h1 id="统计学基本知识（一）"><a href="#统计学基本知识（一）" class="headerlink" title="统计学基本知识（一）"></a>统计学基本知识（一）</h1><p>此文目的旨在对统计学知识进行回顾</p><h2 id="样本和总体"><a href="#样本和总体" class="headerlink" title="样本和总体"></a>样本和总体</h2><hr><ul><li><strong>总体</strong>：研究对象的整个群体</li><li><strong>样本</strong>：从总体中抽取的部分，用于代表总体的整体情况</li><li>数学符号的区别:<br>总体均值常用 μ，样本均值常用 $\overline{X}$</li></ul><h3 id="总体方差"><a href="#总体方差" class="headerlink" title="总体方差"></a><a href="#总体方差" title="总体方差"></a>总体方差</h3><ul><li><strong>方差</strong>：衡量变量或者一组随机数据离散程度的度量</li><li><strong>公式</strong>：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/var.png" alt><br>其中 N 为总体数目</li></ul><h3 id="样本方差"><a href="#样本方差" class="headerlink" title="样本方差"></a><a href="#样本方差" title="样本方差"></a>样本方差</h3><ul><li>由于很多统计情景下总体的数目无法直接测算，因此常常使用总体中的部分样本来对总体进行估计</li><li><p>公式：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/var1.png" alt></p></li><li><p>其中 n 为样本数目。值得注意的是，总体的分布并不总是均匀的，如果样本选取的不好，比如样本恰好选择了总体当中数据分布较为集中的部分，所得到样本方差就会很小。在这种情况下，样本方差无法准确反映总体的方差，实际所选取的样本甚至可能并不包括总体均值。这个公式通常会低估总体方差。</p></li><li><p><strong>无偏估计</strong>：也称作无偏样本方差</p></li><li><strong>公式</strong>：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/var3.png" alt></li><li>通常这个指标更加接近总体方差</li></ul><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a><a href="#标准差" title="标准差"></a>标准差</h3><ul><li>方差的平方根</li><li>标准差使得离散程度的估计值恢复跟原始数据一样的量纲</li></ul><h3 id="诸方差公式"><a href="#诸方差公式" class="headerlink" title="诸方差公式"></a><a href="#诸方差公式" title="诸方差公式"></a>诸方差公式</h3><ul><li><p><strong>公式</strong>：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/varzhu.png" alt></p></li><li><p>证明过程此处不表，由原总体方差公式平方和展开求解可得。</p></li></ul><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a><a href="#期望" title="期望"></a>期望</h3><ul><li>亦即总体的均值，此处一般指总体无穷的情形。因此在计算平均值时无法像有穷情形下一样，计算通常使用频率来代替，而频率则由概率分布得出。</li><li><strong>公式</strong>：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/qiwang.png" alt></li></ul><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a><a href="#概率密度函数" title="概率密度函数"></a>概率密度函数</h3><p>前文所提到的统计量均为离散型数据，此处提出的概念为连续型数据。在连续型数据当中，想要估计变量恰好为某一个精确值的概率几乎是不可能的，这也可以解释为什么在我们的教材当中认为连续型变量当中等于某一固定值的概率为0。因此通常我们在估计概率的时候会允许一定的容差。在此前提下，统计学提出了概率密度函数的概念，以微积分为工具来测算在我们允许的容差范围内某一事件发生的概率，也就是一个抽象概念下的曲线面积——这一曲线就是概率密度函数。注意，所有事件发生的概率之和应当为1，因此曲线总面积也当为1。</p><h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a><a href="#二项分布" title="二项分布"></a>二项分布</h2><h3 id="一个简单的案例"><a href="#一个简单的案例" class="headerlink" title="一个简单的案例"></a><a href="#一个简单的案例" title="一个简单的案例"></a>一个简单的案例</h3><ul><li>连续抛五次硬币，并计算正面朝上的概率</li><li>此处涉及排列组合的问题，通过计算可以看出一个神奇的地方，你会发现正面朝上0、1、2、3、4、5次的概率分别与正面朝上5、4、3、2、1、0次的概率一样。这是因为事件硬币正面朝上 n 次等同于事件反面朝上 5 - n 次，而在这个案例中正面朝上的概率与反面朝上的概率恰好相等。</li><li>总结可得公式如下：</li></ul><p><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/erxiang.png" alt></p><ul><li>其中 N 是试验的次数，p 是事件A发生的概率，1-p 则是事件A的互斥事件发生的概率。二项式系数表示每次独立事件可能发生的所有情形。</li></ul><h3 id="二项分布的期望值"><a href="#二项分布的期望值" class="headerlink" title="二项分布的期望值"></a><a href="#二项分布的期望值" title="二项分布的期望值"></a>二项分布的期望值</h3><ul><li>公式：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/erxiangqiwang.png" alt></li><li><strong>证明</strong>：<br>核心点在于通过期望的计算公式提取出 np 项，通过换元把剩余部分转化为二项分布概率之和即为1。</li></ul><h3 id="泊松过程"><a href="#泊松过程" class="headerlink" title="泊松过程"></a><a href="#泊松过程" title="泊松过程"></a>泊松过程</h3><ul><li>假设 X 为一小时内通过的车辆，假设期望值的最好估计值是 λ \lambdaλ 。则这个过程可以近似为60分钟内有多少车辆经过——这样便可以近似地看作一个二项分布。但是实际上一分钟很有可能通过不止一辆车，则这个时候可以选取更小的细分区间来近似：秒、毫秒…不断地重复这一过程，得到的结果就是泊松过程。</li></ul><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a><a href="#泊松分布" title="泊松分布"></a>泊松分布</h3><ul><li><p><strong>公式</strong>：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/posong.png" alt></p></li><li><p><strong>证明</strong>：<br>本质上是使用二项分布的公式进行计算，但是二项分布公式中的试验次数 N 此时趋近于无穷大。</p></li></ul><h3 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a><a href="#大数定理" title="大数定理"></a>大数定理</h3><ul><li><strong>核心思想</strong>：样本数量足够大的时候，样本均值将趋近于总体均值</li></ul><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a><a href="#正态分布" title="正态分布"></a>正态分布</h3><ul><li><strong>公式</strong>：<br><img src="/2019/05/01/tong-ji-xue/tong-ji-xue-1/05/05/tong-ji-xue-ji-chu-yi/zhengtai.png" alt></li><li>均值会影响分布曲线的中心位置，而标准差则会影响分布曲线的陡峭程度。</li><li>与二项分布不同的是，正态分布不能只看某一点的概率，所以应该看某一区间内曲线下的面积，即特定区间下的积分值。</li><li><strong>CDF函数</strong>：累积分布函数。通过不同上限的累积分布函数值相减可得对应区间的概率。</li></ul><h3 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a><a href="#标准正态分布" title="标准正态分布"></a>标准正态分布</h3><p>均值为0，标准差为1的正态分布</p><h3 id="Z分数"><a href="#Z分数" class="headerlink" title="Z分数"></a><a href="#Z分数" title="Z分数"></a>Z分数</h3><ul><li>离均值有多少个标准差远</li></ul><h3 id="经验法则"><a href="#经验法则" class="headerlink" title="经验法则"></a><a href="#经验法则" title="经验法则"></a>经验法则</h3><ul><li>均值一个标准差区间：68%</li><li>均值两个标准差区间：95%</li><li>均值三个标准差区间：99.7%</li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXCEL-字符串</title>
      <link href="/2019/04/30/excel/excel-zi-fu-chuan/"/>
      <url>/2019/04/30/excel/excel-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="EXCEL-字符串"><a href="#EXCEL-字符串" class="headerlink" title="EXCEL-字符串"></a>EXCEL-字符串</h2><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><blockquote><p>用途：将数值转换为按指定数字格式表示的文本。</p></blockquote><ul><li><p>语法：Text(Value，Format_Text)</p></li><li><p>参数：Value是数值、计算结果是数值的公式、或对数值单元格的引用；Format_Text是所要选用的文本型数字格式，即“单元格格式”对话框“数字”选项卡的“分类”列表框中显示的格式，它不能包含星号“*”。<br>注意：使用“单元格格式”对话框的“数字”选项卡设置单元格格式，只会改变单元格的格式而不会影响其中的数值。使用函数Text可以将数值转换为带格式的文本，而其结果将不再作为数字参与计算。</p></li></ul><h3 id="Search或Searchb"><a href="#Search或Searchb" class="headerlink" title="Search或Searchb"></a>Search或Searchb</h3><blockquote><p>用途：返回从start_Num开始首次找到特定字符或文本串的位置编号。其中search以字符数为单位，Searchb以字节数为单位。</p></blockquote><ul><li><p>语法：Search(Find_Text，Within_Text，Start_Num)，Searchb(Find_Text，Within_Text，Start_Num)</p></li><li><p>参数：Find_Text是要查找的文本，可以使用通配符，包括问号“?”和星号“*”。其中问号可匹配任意的单个字符，星号可匹配任意的连续字符。如果要查找实际的问号或星号，应当在该字符前键入波浪线“~”。Within_Text是要在其中查找Find_Text的文本。Start_Num是Within_Text中开始查找的字符的编号。如果忽略Start_Num，则假定其为1。</p></li></ul><h3 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h3><blockquote><p>用途：Find用于查找其他文本串(Within_Text)内的文本串(Find_Text)，并从within_Text的首字符开始返回find_Text的起始位置编号。此函数适用于双字节字符，它区分大小写但不允许使用通配符。</p></blockquote><ul><li><p>语法：Find(Find_Text，Within_Text，Start_Num)</p></li><li><p>参数：Find_Text是待查找的目标文本；Within_Text是包含待查找文本的源文本；Start_Num指定从其开始进行查找的字符，即within_Text中编号为1的字符。如果忽略start_Num，则假设其为1。</p></li></ul><h3 id="Concatenate"><a href="#Concatenate" class="headerlink" title="Concatenate"></a>Concatenate</h3><blockquote><p>用途：将若干文字串合并到一个文字串中，其功能与”&amp;”运算符相同。</p></blockquote><ul><li><p>语法：Concatenate(Text1，Text2，…)</p></li><li><p>参数：Text1，Text2，…为1到30个将要合并成单个文本的文本项，这些文本项可以是文字串、数字或对单个单元格的引用。</p></li></ul><h3 id="Left或Leftb"><a href="#Left或Leftb" class="headerlink" title="Left或Leftb"></a>Left或Leftb</h3><blockquote><p>用途：根据指定的字符数返回文本串中的第一个或前几个字符。此函数用于双字节字符。</p></blockquote><ul><li><p>语法：Left(Text，Num_Chars)或leftb(Text，Num_Bytes)</p></li><li><p>参数：Text是包含要提取字符的文本串；Num_Chars指定函数要提取的字符数，它必须大于或等于0。Num_Bytes按字节数指定由leftb提取的字符数。</p></li></ul><h3 id="Right或Rightb"><a href="#Right或Rightb" class="headerlink" title="Right或Rightb"></a>Right或Rightb</h3><blockquote><p>用途：Right根据所指定的字符数返回文本串中最后一个或多个字符。Rightb根据所指定的字节数返回文本串中最后一个或多个字符。</p></blockquote><ul><li><p>语法：Right(Text，Num_Chars)，Rightb(Text，Num_Bytes)</p></li><li><p>参数：Text是包含要提取字符的文本串；Num_Chars指定希望right提取的字符数，它必须大于或等于0。如果num_Chars大于文本长度，则right返回所有文本。如果忽略num_Chars，则假定其为1。Num_Bytes指定欲提取字符的字节数。</p></li></ul><h3 id="Len或Lenb"><a href="#Len或Lenb" class="headerlink" title="Len或Lenb"></a>Len或Lenb</h3><blockquote><p>用途：Len返回文本串的字符数。Lenb返回文本串中所有字符的字节数。</p></blockquote><ul><li><p>语法：Len(Text)或Lenb(Text)</p></li><li><p>参数：Text待要查找其长度的文本。</p></li><li><p><strong>注意：</strong> 此函数用于双字节字符，且空格也将作为字符进行统计。</p></li></ul><h3 id="Lower"><a href="#Lower" class="headerlink" title="Lower"></a>Lower</h3><blockquote><p>用途：将一个文字串中的所有大写字母转换为小写字母。</p></blockquote><ul><li><p>语法：Lower(Text)</p></li><li><p>参数：Text是包含待转换字母的文字串。</p></li><li><p><strong>注意：</strong> Lower函数不改变文字串中非字母的字符。Lower与proper和upper函数非常相似。</p></li></ul><h3 id="Upper"><a href="#Upper" class="headerlink" title="Upper"></a>Upper</h3><blockquote><p>用途：将文本转换成大写形式。</p></blockquote><ul><li><p>语法：Upper(Text)</p></li><li><p>参数：Text为需要转换成大写形式的文本，它可以是引用或文字串。</p></li></ul><h3 id="Mid或Midb"><a href="#Mid或Midb" class="headerlink" title="Mid或Midb"></a>Mid或Midb</h3><blockquote><p>用途：Mid返回文本串中从指定位置开始的特定数目的字符，该数目由用户指定。Midb返回文本串中从指定位置开始的特定数目的字节，该数目由用户指定。Midb函数可以用于双字节字符。</p></blockquote><ul><li><p>语法：Mid(Text，Start_Num，Num_Chars)或midb(Text，Start_Num，Num_Bytes)</p></li><li><p>参数：Text是包含要提取字符的文本串。Start_Num是文本中要提取的第一个字符的位置，文本中第一个字符的start_Num为1，以此类推；Num_Chars指定希望mid从文本中返回字符的个数；Num_Bytes指定希望midb从文本中按字节返回字符的个数。</p></li></ul><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><blockquote><p>用途：去除字符串中的空格</p></blockquote><ul><li>语法：trim(Text)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXCEL-日期函数</title>
      <link href="/2019/04/30/excel/excel-ri-qi-han-shu/"/>
      <url>/2019/04/30/excel/excel-ri-qi-han-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="EXCEL-日期函数"><a href="#EXCEL-日期函数" class="headerlink" title="EXCEL-日期函数"></a>EXCEL-日期函数</h2><h1 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h1><h3 id="Now"><a href="#Now" class="headerlink" title="Now"></a>Now</h3><blockquote><p>用途：返回当前日期和时间所对应的序列号。</p></blockquote><ul><li>语法：Now()</li></ul><h3 id="Today"><a href="#Today" class="headerlink" title="Today"></a>Today</h3><blockquote><p>用途：返回系统当前日期的序列号。</p></blockquote><ul><li>语法：Today()</li></ul><h3 id="Weekday"><a href="#Weekday" class="headerlink" title="Weekday"></a>Weekday</h3><blockquote><p>用途：返回某日期的星期数。在默认情况下，它的值为1(星期天)到7(星期六)之间的一个整数。</p></blockquote><ul><li><p>语法：Weekday(Serial_Number，Return_Type)</p></li><li><p>参数：Serial_Number是要返回日期数的日期，它有多种输入方式：带引号的文本串(如”2001/02/26”)、序列号(如35825表示1998年1月30日)或其他公式或函数的结果(如dateValue(“2000/1/30”))。Return_Type为确定返回值类型的数字，数字1或省略则1至7代表星期天到数星期六，数字2则1至7代表星期一到星期天，数字3则0至6代表星期一到星期天。 </p></li></ul><h3 id="Weeknum"><a href="#Weeknum" class="headerlink" title="Weeknum"></a>Weeknum</h3><blockquote><p>用途：返回一个数字，该数字代表一年中的第几周。</p></blockquote><ul><li><p>语法：Weeknum(Serial_Num，Return_Type)</p></li><li><p>参数：Serial_Num代表一周中的日期。应使用date 函数输入日期，或者将日期作为其他公式或函数的结果输入。Return_Type为一数字，确定星期计算从哪一天开始。默认值为 1。</p></li></ul><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><blockquote><p>Date  Date(year, month,day)  </p></blockquote><blockquote><p>Time time(hour, minute, second)   </p></blockquote><h3 id="Datedif"><a href="#Datedif" class="headerlink" title="Datedif"></a>Datedif</h3><blockquote><p>用途：计算两个日期的间隔。</p></blockquote><ul><li><p>语法：Datedif DATEDIF(start_date,end_date,unit)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DATEDIF(开始日期，结束日期，Type (yd,md,ym, y,m,d))</p></li><li><p>参数：Start_date 为一个日期，它代表时间段内的第一个日期或起始日期。(起始日期必须在1900年之后)。End_date 为一个日期，它代表时间段内的最后一个日期或结束日期。Unit 为所需信息的返回类型。</p></li><li><p><strong>注：</strong> </p><blockquote><p>“Y” 时间段中的整年数。<br>“M” 时间段中的整月数。<br>“D” 时间段中的天数。<br>“MD” 起始日期与结束日期的同月间隔天数。 忽略日期中的月份和年份。<br>“YD” 起始日期与结束日期的同年间隔天数。忽略日期中的年份。<br>“YM” 起始日期与结束日期的同年间隔月数。忽略日期中年份  </p></blockquote></li></ul><h3 id="截取时间中的数值"><a href="#截取时间中的数值" class="headerlink" title="截取时间中的数值"></a>截取时间中的数值</h3><blockquote><p>Year<br>Month<br>Day<br>Hour<br>Minute<br>second</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXCEL-逻辑函数</title>
      <link href="/2019/04/30/excel/excel-luo-ji-han-shu/"/>
      <url>/2019/04/30/excel/excel-luo-ji-han-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="EXCEL-逻辑函数"><a href="#EXCEL-逻辑函数" class="headerlink" title="EXCEL-逻辑函数"></a>EXCEL-逻辑函数</h2><h1 id="逻辑函数："><a href="#逻辑函数：" class="headerlink" title="逻辑函数："></a>逻辑函数：</h1><h3 id="If"><a href="#If" class="headerlink" title="If"></a>If</h3><blockquote><p>用途：执行逻辑判断，它可以根据逻辑表达式的真假，返回不同的结果，从而执行数值或公式的条件检测任务。  </p></blockquote><ul><li><p>语法：If(Logical_Test，Value_If_True，Value_If_False)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If(条件，满足条件时执行，不满足条件时执行)     </p></li><li><p>参数：Logical_Test计算结果为True或False的任何数值或表达式；Value_If_True是Logical_Test为True时函数的返回值，如果Logical_Test为True并且省略了Value_If_True，则返回True。而且Value_If_True可以是一个表达式；Value_If_False是Logical_Test为False时函数的返回值。如果Logical_Test为False并且省略Value_If_False，则返回False。Value_If_False也可以是一个表达式。</p></li></ul><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><blockquote><p>用途：返回逻辑值：如果所有参数值均为逻辑“真（TRUE）”，则返回逻辑“真（TRUE）”，反之返回逻辑“假（FALSE）”。  </p></blockquote><ul><li><p>语法：AND(logical1,logical2,  …) 　<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AND(条件1，条件2,….)</p></li><li><p>参数：Logical1,Logical2,Logical3……：表示待测试的条件值或表达式，最多至30个。</p></li></ul><h3 id="OR"><a href="#OR" class="headerlink" title="OR　"></a>OR　</h3><blockquote><p>用途：返回逻辑值，仅当所有参数值均为逻辑“假（FALSE）”时返回函数结果逻辑“假（FALSE）”，否则都返回逻辑“真（TRUE）”。　　</p></blockquote><ul><li><p>语法：OR(logical1,logical2,  …)　<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OR(条件1，条件2,….)　</p></li><li><p>参数：Logical1,Logical2,Logical3……：表示待测试的条件值或表达式，最多至0个.</p></li></ul><h3 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h3><blockquote><p>用途：以函数的逻辑值求反</p></blockquote><ul><li>语法：Not(logical)　<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Not(条件)　</li></ul><h3 id="Iseven"><a href="#Iseven" class="headerlink" title="Iseven"></a>Iseven</h3><blockquote><p>用途：测试参数的奇偶性，如果参数为偶数返回True，否则返回False。</p></blockquote><ul><li><p>语法：Iseven(Number)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Iseven(数值)  </p></li><li><p>Number待测试的数值。如果参数值不是整数，则自动截去小数部分取整。<br><strong>注意：</strong> 该函数必须加载“分析工具库”方能使用。如果参数Number不是数值，Iseven函数返回错误值#Value!。</p></li></ul><h3 id="Isodd"><a href="#Isodd" class="headerlink" title="Isodd"></a>Isodd</h3><blockquote><p>用途：测试参数的奇偶性，如果参数为奇数返回True，否则返回False。 </p></blockquote><ul><li><p>语法：Isodd(Number)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Iseven(数值)   </p></li><li><p>参数：Number待测试的数值。如果参数不是整数，则自动截去小数部分取整。<br><strong>注意：</strong> 该函数必须加载“分析工具库”方能使用。</p></li></ul><h3 id="Iserror"><a href="#Iserror" class="headerlink" title="Iserror"></a>Iserror</h3><blockquote><p>用途：检查一个值是否为错误   </p></blockquote><ul><li><p>语法：iserror(value)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iserror(运算结果)  </p></li><li><p>参数：value可以是一个表达式，如果结果有错则返回TRUE。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXCEL-查找引用</title>
      <link href="/2019/04/30/excel/excel-cha-zhao-yin-yong/"/>
      <url>/2019/04/30/excel/excel-cha-zhao-yin-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="EXCEL-查找引用"><a href="#EXCEL-查找引用" class="headerlink" title="EXCEL-查找引用"></a>EXCEL-查找引用</h2><h1 id="查找引用"><a href="#查找引用" class="headerlink" title="查找引用"></a>查找引用</h1><h3 id="VLOOKUP"><a href="#VLOOKUP" class="headerlink" title="VLOOKUP"></a>VLOOKUP</h3><blockquote><p>用途：在表格或数值数组的首列查找指定的数值，并由此返回表格或数组当前行中指定列处的数值。</p></blockquote><ul><li><p>语法：VLOOKUP(lookup_value，table_array，col_index_num，range_lookup)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;VLOOKUP(找谁，在哪里找，第几列，怎么找) </p></li><li><p>参数：Lookup_value为需要在数据表第一列中查找的数值，Table_array 为需要在其中查找数据区域。Col_index_num 为table_array 中待返回的匹配值的列序号。Range_lookup为一逻辑值，指明函数VLOOKUP 返回时是精确匹配还是近似匹配。如果Range_lookup为 1或省略，则返回近似匹配值（模糊匹配），<br>如果找不到精确匹配值，则返回小于lookup_value 的最大数值；<br>如果range_value 为0， 函数VLOOKUP 将返回精确匹配值。</p></li><li><p><strong>注意：</strong> 1. 查找值一定要在第一列。<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;2. 模糊匹配时第一列一定要升序排列。</p></li></ul><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><blockquote><p>用途：返回在指定方式下与指定数值匹配的数组中元素的相应位置。如果需要找出匹配元素的位置而不是匹配</p></blockquote><ul><li><p>元素本身，则应该使用match函数。</p></li><li><p>语法：Match(Lookup_Value，Lookup_Array，Match_Type)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Match(找谁，在哪里找，怎么找)</p></li><li><p>参数：Lookup_Value为需要在数据表中查找的数值，它可以是数值(或数字、文本或逻辑值)、对数字、文本或逻辑值的单元格引用。Lookup_Array是可能包含所要查找的数值的连续单元格区域，Lookup_Array可以是数组或数组引用；Match_Type为数字-1、0或1，它说明Excel如何在Lookup_Array中查找Lookup_Value。如果Match_Type为1，函数Match查找小于或等于Lookup_Value的最大数值。如果Match_Type为0，函数Match查找等于Lookup_Value的第一个数值。如果Match_Type为-1，函数Match查找大于或等于Lookup_Value的最小数值。</p></li></ul><h3 id="INDEX（）"><a href="#INDEX（）" class="headerlink" title="INDEX（）"></a>INDEX（）</h3><blockquote><p>用途：返回列表或数组中的元素值，此元素由行序号和列序号的索引值进行确定。　　</p></blockquote><ul><li><p>使用格式：INDEX(array,row_num,column_num)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;INDEX(范围，范围里的行号, 范围里的列号)</p></li><li><p>参数说明：Array代表单元格区域或数组常量；Row_num表示指定的行序号（如果省略row_num，则必须有  column_num）；Column_num表示指定的列序号（如果省略column_num，则必须有 row_num）</p></li></ul><h3 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h3><blockquote><p>用途：选取区域数据</p></blockquote><ul><li>使用格式： Offset(相对位置， 下移几行，右移几列， 高，宽)    </li></ul><h3 id="Indirect"><a href="#Indirect" class="headerlink" title="Indirect"></a>Indirect</h3><blockquote><p>为对单元格的引用， </p></blockquote><ul><li>使用格式：INDIRECT(ref_text,[a1])<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Indirect(字符串)</li></ul><h3 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h3><blockquote><p>返回单元格的列号</p></blockquote><ul><li>Column([单元格])</li></ul><h3 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h3><blockquote><p>返回单元格的行号</p></blockquote><ul><li>Row （[单元格]）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言常包</title>
      <link href="/2019/04/29/r/r/"/>
      <url>/2019/04/29/r/r/</url>
      
        <content type="html"><![CDATA[<h2 id="R语言常用包"><a href="#R语言常用包" class="headerlink" title="R语言常用包"></a>R语言常用包</h2><ol><li>计算总体的均值：mean(x);</li><li>计算总体的方差：var(x);</li><li>计算总体的标准差：sd(x);</li><li>计算总体的中位数：median(x)；</li><li>计算总体四分位距：c(quantile(data,probs=c(0.75)))-c(quantile(data,probs=c(0.25)));</li><li>计算总体的离散系数：总体标准差/总体7.均值 sd(x)/mean(x)；</li><li>计算总体全距：c(max(x)-min(x));</li><li>计算总体的(不及格率)：length(x[x&lt;60])/length(x);</li><li>求和：sum(x);</li><li>从小到大排序：sort(x);</li><li>按原数据排序的反方向排序：rev(x);</li><li>求向量的置：rank(x);</li><li>求积：prod；</li><li>在外向量插入元素：append(x,1:3,after=3)</li><li>把缺省值na置0：x[is.na(x)]&lt;-0;</li><li>把NA过滤掉：u&lt;-x[!is.na(x)];</li><li>矩阵的转置：t(x);</li><li>求矩阵的对角线：diag(x);</li><li>求矩阵的逆矩阵：solve(x);</li><li>求矩阵的特征值和特征矩阵：x.eigen&lt;-eigen(x,symmetric=T);</li><li>求矩阵(数组)的维数：dim(x);</li><li>矩阵的行数：nrow(x);</li><li>矩阵的列数：ncol(x);</li><li>求矩阵的下三角矩阵：lower.tri(x); x[lower.tri(x)]=0; x[upper.tri(x)]=0;</li><li>数组的定义：array;</li><li>创建因子:factor(x);</li><li>因子的水平：level(x);</li><li>数据框的合并：rbind(x1,x2);</li><li>求绝对值：abs(x);</li><li>开方：sqrt(x);</li><li>不大于x的最大整数：floor(x);</li><li>不小于x的最大整数：ceilling(x);</li><li>去掉小数点之后的数：trunc(x);</li><li>保留小数点的位数：round(x,digits=2),digits是保留的位数</li><li>编辑数据集：x&lt;-edit(x)等价于fix(x)；</li><li>连接字符：paste(x1,x2,x3);</li><li>查看某个函数的参数：args( );</li><li>查看某个包中包含的所有函数：help(package=” ”)</li><li>更改数据框的列名为小写字母：names(x)&lt;-tolower(names(x))</li><li>将某进制的数转换为十进制的数：strtoi(“1111”,base=2) base 指的是某进制的数</li><li>将十进制的数转换为二进制的数：intToBits(132)</li><li>计算区域中心坐标： coordinates()</li><li>用来解决向量或者数据框重复值的函数，它会返回一个TRUE和FALSE的向量: duplicated()</li><li>根据数据框中的某一列进行排序：sh[order(sh[,1]),]或者arrange(df,.(var1),(.varb))</li><li>简单随机抽样：sample(x,n,replace=T,prob=NULL)x是样本，n是抽取个数，replace代表是否是有放回抽样，prob是抽取各个样本的概率。</li><li>分层抽样：strata(data,stratanames=NULL,size,method=c(“srswor”,”srswr”,”poission”,”systematic”),pik,description=FALSE)data为数据集，stratanames中放置进行分层所依据的变量名称，size设置各层中将要抽出的观测样本数，method用于选择其中的抽样方法（无放回、有放回、泊松、系统抽样），pik用于设置各层的抽样概率，description选择是否输出含有各层基本信息的结果。</li><li>整群抽样：cluster(data,clustername,size,method=c(“srswor”,”srswr”,”poisson”,”systematic”),pik,description=FALSE)</li><li>给出数据的属性列表：attributes()</li><li>查看数据的内部结构：str()</li><li>查看变量的详细情况：describe()（Hmisc包）</li><li>查看更加详细的数据情况：basicStats()（fBasics包）</li><li>查看数据的缺失值分布状况：md.pattern()（mice包）</li><li>显示数据的行列数：nrow();ncol();</li><li>点图：dotchart()</li><li>处理缺失值的函数：mice()(mice包)</li><li>寻找噪声数据：outlier()(outliers包)</li><li>卡方检验：chisq.test(x)</li><li>求两列数据的协方差：cov(x)</li><li>数据的标准化：scale()</li><li>判断是否存在完整观测样本：complete.cases()</li><li>对向量进行赋值：assign(“w”,c(1,2))</li><li>返回向量的范围：range(x)</li><li>求向量的连乘积：prod(x)</li><li>向向量中添加元素：append(y,10:5,after=5)</li><li>矩阵之间的乘法：A%*%B</li><li>取得矩阵的对角元素：diag()</li><li>求矩阵的特征值和特征向量：eigen()</li><li>绘制函数图像：curve()</li><li>改变缺省调色板：palette()</li></ol>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo入门</title>
      <link href="/2019/04/28/hexo-ru-men/"/>
      <url>/2019/04/28/hexo-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><ul><li>其实早在之前刚接触HTML的时候，我就一直想搭建一个属于自己的博客，但由于种种原因一直没有去学习这方面的知识，最近一周和一个朋友讲到，所以就坚定下来搭好这个博客。从开始到搭建完成的过程中踩过很多坑，因为在这之前对Github一点了解较少，靠着搜素框，看着各个大佬的教程，不断的跳进一个又一个坑，但最后还是搭建好了。<h3 id="那么为什么要搭建自己的博客？-为什么你要写博客？—陈素封"><a href="#那么为什么要搭建自己的博客？-为什么你要写博客？—陈素封" class="headerlink" title="那么为什么要搭建自己的博客？ 为什么你要写博客？—陈素封"></a>那么为什么要搭建自己的博客？ <a href="https://zhuanlan.zhihu.com/p/19743861?columnSlug=cnfeat" target="_blank" rel="noopener">为什么你要写博客？—陈素封</a></h3></li></ul><ol><li>重新认识自己</li><li>提供持续学习的动力</li><li>积累更多知识</li><li>提高将事情将清楚的能力</li><li>分享带来的连锁反应</li><li>找到志同道合的人</li><li>记录成长</li><li>培养持续做一件事情的能力</li><li>讨论反思</li><li>搜寻到你意想不到东西</li><li>一个人在做一件属于自己的事<h3 id="以上11件肯定可以实现一半以上-fighting"><a href="#以上11件肯定可以实现一半以上-fighting" class="headerlink" title="以上11件肯定可以实现一半以上     fighting!"></a>以上11件肯定可以实现一半以上     fighting!</h3><h2 id="1-开始搭建"><a href="#1-开始搭建" class="headerlink" title="1. 开始搭建"></a>1. 开始搭建</h2></li></ol><ul><li><p>参考：<a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a></p></li><li><p>参考：<a href="http://cyzus.github.io/2015/06/21/github-build-blog/" target="_blank" rel="noopener">傻瓜都可以利用github pages建博客</a>  </p></li></ul><hr><ol><li>前期工作<ul><li>了解github，注册号github账号。</li><li>在自己的账号下面创建一个 <strong>XX</strong>.github.io <strong>XX</strong>为你的名字。</li><li>建完仓库后，在当前页面右边选择Settings，进入设置页面，在这里生成你的github pages。随便选择一个模板（后面会改）。</li><li>预览页面 在浏览器中输入  <strong>XX</strong>.github.io，这样就进入了你的博客页面。</li></ul></li></ol><ol start="2"><li>下载安装一些使用到的软件  </li></ol><p>下载安装github   </p><ul><li><a href="https://desktop.github.com/" target="_blank" rel="noopener">https://windows.github.com/</a>  </li><li><a href="https://www.git-scm.com/downloads" target="_blank" rel="noopener">https://www.git-scm.com/downloads</a></li></ul><blockquote><p>个人习惯这两个搭配上一起用，更好管理。</p></blockquote><p>下载安装node  </p><ul><li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>   </li></ul><p>下载安装Hexo </p><ul><li><p>在你要安装Hexo的目录下 （新建文件夹）右键 Git Bash</p><pre><code>  npm install hexo-cli -g     hexo init #初始化网站   npm install   hexo g #生成或 hexo generate    hexo s #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000  查看了</code></pre></li></ul><h2 id="2-安装主题"><a href="#2-安装主题" class="headerlink" title="2. 安装主题"></a>2. 安装主题</h2><ol><li>先清空之前的缓存<br> <code>hexo clean</code>  </li><li>拷贝一份主题到本地<br> <code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code>  </li><li>切换主题<br> 修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery  </li><li>更新主题<br> <code>hexo g</code><br> <code>hexo s</code><blockquote><p>此时刷新<a href="http://localhost:4000/页面就能看到新的主题了" target="_blank" rel="noopener">http://localhost:4000/页面就能看到新的主题了</a></p></blockquote></li></ol><h2 id="3-部署到github"><a href="#3-部署到github" class="headerlink" title="3. 部署到github"></a>3. 部署到github</h2><ol><li><p>编辑更目录下_config.yml文件</p><pre><code> deploy:     type: git     repo: git@github.com:XX/XX.github.io.git  #这里的网址填你自己的     branch: master</code></pre><blockquote><p>此处有大坑，每个：必须有一个空格，所有编辑_config.yml文件内 冒号后必须有空格。</p></blockquote><p>  保存后安装一个扩展：  </p><p>  <code>npm install hexo-deployer-git --save</code> </p></li><li><p>使用SSH Keys的设置  </p><pre><code> ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; #生成新的key文件,邮箱地址填你的Github地址    #Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;    #接下来会让你输入密码  </code></pre></li><li><p>添加SSH Key到Github</p><p> 进入github首页–&gt;头像（Settings）–&gt; 添加SSH Key–&gt;New SSH Key</p><p> 找到 系统当前用户目录下(开启查看隐藏文件)<br> .ssh id_rsa.pub文件以文本方式打开。打开之后全部复制到key中<br> Title 随便写个标记<br> 完成后就可以测试一下是否成功  </p><pre><code> ssh -T git@github.com #看到successfully就便是成功了</code></pre></li><li><p>上传到github</p><p> <code>hexo d</code><br> 这时再刷新 XX.github.io 就可以看到你的博客了</p><h2 id="4-多台电脑更新博客"><a href="#4-多台电脑更新博客" class="headerlink" title="4. 多台电脑更新博客"></a>4. 多台电脑更新博客</h2></li><li><p>原理  </p><blockquote><p>利用git分支实现<br> hexo生成的静态博客文件默认放在master分支上。<br> hexo的源文件（部署环境文件）可以都放在hexo分支上（可以新创建一个hexo分支），换新电脑时，直接git clone hexo分支（<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:XX/XX.github.io.git）即可。  </p></blockquote></li><li><p>实现流程  </p><ol><li><p>对username.github.io仓库新建hexo分支，并克隆   </p><blockquote><p>在Github的username.github.io仓库上新建一个xxx分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，save保存；然后将该仓库克隆到本地，进入该XX.github.io文件目录  </p></blockquote></li><li><p>完成上面步骤后，在当前目录使用Git Bash执行git branch命令查看当前所在分支，应为新建的分支hexo：  </p><pre><code>   $git branch      *hexo  </code></pre></li><li><p>将本地博客的部署文件拷贝进xx.github.io文件目录</p><p>进入xx.github.io文件目录下，将该目录下的全部文件提交hexo分支，提交之前需注意：</p><blockquote><p>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。  </p></blockquote></li></ol></li><li><p>提交hexo分支</p><pre><code> 使用GitHub Desktop  点击 commit to hexo   点击 pull origin  这样就将博客的hexo部署环境提交到GitHub个人仓库的hexo分支</code></pre><p> 现在可以在GitHub上的username.github.io仓库看到两个分支的差异了。  </p><blockquote><p>master分支和hexo分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；hexo分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内互不冲突，完美！</p></blockquote></li><li><p>在新电脑上编辑博客</p><blockquote><ul><li>将新电脑的生成的ssh key添加到GitHub账户上  </li><li>在新电脑上克隆username.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支</li><li>切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉  node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下)<br><code>nmp install</code></li></ul></blockquote><p> 注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先  </p><pre><code>`git pull`</code></pre></li></ol><p>我一般就是使用 GitHub Desktop 来维护博客部署文件，Git Bash 来更新博客。<br>这样就基本完成了，当然还有一些坑没填，后期会慢慢写到。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/27/hello-world/"/>
      <url>/2019/04/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
